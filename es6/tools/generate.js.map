{"version":3,"sources":["../../source/tools/generate.js"],"names":["parseString","DIGIT_PLACEHOLDER","phone_number_types","input","version","included_countries","extended","included_phone_number_types","_type","indexOf","Promise","reject","parseStringPromisified","then","xml","country_calling_code_to_countries","countries","territory","country_code","$","id","has","country","phone_code","countryCode","idd_prefix","internationalPrefix","default_idd_prefix","preferredInternationalPrefix","ext","preferredExtnPrefix","leading_digits","leadingDigits","national_number_pattern","generalDesc","nationalNumberPattern","replace","national_prefix","nationalPrefix","national_prefix_for_parsing","nationalPrefixForParsing","undefined","national_prefix_transform_rule","nationalPrefixTransformRule","national_prefix_formatting_rule","nationalPrefixFormattingRule","national_prefix_is_optional_when_formatting","nationalPrefixOptionalWhenFormatting","Boolean","types","get_phone_number_types","examples","get_phone_number_examples","Error","availableFormats","formats","numberFormat","map","number_format","pattern","leading_digits_patterns","format","international_format","intlFormat","filter","mainCountryForCode","unshift","push","phoneNumberMetadata","territories","Object","keys","main_country_for_region_code","main_country_for_region","visited_countries","country_calling_code","country_codes","populate_possible_lengths","all_types_required","length","fixed_line","mobile","country_calling_codes","rule","reduce","output","type","camel_cased_type","underscore_to_camel_case","possible_lengths","possibleLengths","national","possible_lengths_local","localOnly","example","exampleNumber","string","match","toUpperCase","parse_possible_lengths","possible_length_string","TypeError","lengths","Set","split","min_max","slice","parseInt","_","min","max","i","add","arrays_are_equal","a1","a2","every","metadata","type_possible_lengths","Array","from","type_possible_lengths_local","delete","sort","a","b","size","resolve","error","result"],"mappings":";;AAAA,SAASA,WAAT,QAA4B,QAA5B;;AAEA,SAASC,iBAAT,QAAkC,cAAlC;AACA;;AAEA,IAAMC,qBACN,CACC,cADD,EAEC,WAFD,EAGC,aAHD,EAIC,MAJD,EAKC,iBALD,EAMC,OAND,EAOC,KAPD,EAQC,YARD,EASC,YATD,EAUC,QAVD,CADA;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAASC,KAAT,EAAgBC,OAAhB,EAAyBC,kBAAzB,EAA6CC,QAA7C,EAAuDC,2BAAvD,EACf;AACC;AACA,KAAIA,2BAAJ,EACA;AACC,uBAAoBA,2BAApB,kHACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,OADWC,KACX;;AACC,OAAIN,mBAAmBO,OAAnB,CAA2BD,KAA3B,IAAoC,CAAxC,EACA;AACC,WAAOE,QAAQC,MAAR,iCAA6CH,KAA7C,CAAP;AACA;AACD;AACD;;AAED;AACA,QAAOI,uBAAuBT,KAAvB,EAA8BU,IAA9B,CAAmC,UA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","file":"generate.js","sourcesContent":["import { parseString } from 'xml2js'\n\nimport { DIGIT_PLACEHOLDER } from '../AsYouType'\n// import { isSingleIDDPrefix } from '../IDD'\n\nconst phone_number_types =\n[\n\t'premium_rate',\n\t'toll_free',\n\t'shared_cost',\n\t'voip',\n\t'personal_number',\n\t'pager',\n\t'uan',\n\t'voice_mail',\n\t'fixed_line',\n\t'mobile'\n]\n\n// Excessive fields from \"PhoneNumberMetadata.xml\"\n// aren't included to reduce code complexity and size:\n//\n// * `<references>` — a link to ITU (International Telecommunication Union)\n//                    document describing phone numbering plan for a country\n//\n// * `<noInternationalDialling>` — who needs to input non-internationally-dialable phones\n//\n// * `<areaCodeOptional>` — we aren't in the XXth century,\n//                          it's a globalized world, so write your\n//                          phone numbers with area codes.\n//\n// * `<fixedLine>`, `<mobile>`, `<pager>`,\n//   `<tollFree>`, `<premiumRate>`,\n//   `<sharedCost>`, `<personalNumber>`,\n//   `<voip>`, `<uan>`, `<voicemail>` — who needs that in the XXIst century.\n//                                      just go mobile and stop talking nonsense.\n//\n// * `internationalPrefix`,\n//   `preferredInternationalPrefix` — who needs to parse (or format) those weird\n//                                    \"internationally dialed\" phone numbers\n//                                    like \"011 ...\" in the USA.\n//                                    this isn't XXth century, just use mobile phones.\n//\n// * `preferredExtnPrefix` — Localized \" ext. \". E.g. \", доб. \" instead of \" ext. \" for Russia.\n//\n// * `leadingZeroPossible` — (aka \"italian leading zero\")\n//                           who needs to parse a phone number into an integer.\n//                           just keep it as a string.\n//\n// * `carrierCodeFormattingRule` — only used in Brazil and Colombia\n//                                 when dialing from within those countries\n//                                 from mobile phones to fixed line phone numbers.\n//                                 i guess brazilians and colombians\n//                                 already know when to add those carrier codes\n//                                 by themselves (and when not to add them)\n//\n// * `mobileNumberPortableRegion` — is only used to disable phone number type detection\n//\n// * `<possibleLengths>` — is a redundant field to speed up testing of\n//                         whether a phone number format can be used to format\n//                         a particular national (significant) phone number.\n//\n// `libphonenumber/BuildMetadataFromXml.java` was used as a reference.\n// https://github.com/googlei18n/libphonenumber/blob/master/tools/java/common/src/com/google/i18n/phonenumbers/BuildMetadataFromXml.java\n//\n// There are three Xml metadata files in Google's `libphonenumber`:\n//\n//  * PhoneNumberMetadata.xml — core data, used both for parse/format and \"as you type\"\n//\n//  * PhoneNumberAlternateFormats.xml — alternative phone number formats.\n//                                      is presumably used for parsing phone numbers\n//                                      written in \"alternative\" formats.\n//                                      is not used by \"as you type\"\n//                                      presumably because of formats ambiguity\n//                                      when combined with the core data.\n//                                      this metadata is not used in this library\n//                                      as there's no clear description on what to do with it\n//                                      and how it works in the original `libphonenumber` code.\n//\n//  * ShortNumberMetadata.xml — emergency numbers, etc. not used in this library.\n//\n// @returns\n//\n// {\n// \tcountry_calling_codes:\n// \t{\n// \t\t'7': ['RU', 'KZ', ...],\n// \t\t...\n// \t},\n// \tcountries:\n// \t{\n// \t\tRU:\n// \t\t{\n// \t\t\tphone_code: \"7\",\n// \t\t\tnational_number_pattern: \"[347-9]\\\\d{9}\",\n// \t\t\tnational_prefix: \"8\",\n// \t\t\tnational_prefix_formatting_rule: \"8 ($1)\",\n// \t\t\tnational_prefix_is_optional_when_formatting: true,\n// \t\t\ttypes:\n// \t\t\t{\n// \t\t\t\tfixed_line: \"(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15]|6[1-35-79]|7[1-37-9]))\\\\d{7}\",\n// \t\t\t\tmobile: \"9\\\\d{9}\",\n// \t\t\t\t...\n// \t\t\t},\n// \t\t\texamples:\n// \t\t\t{\n// \t\t\t\tfixed_line: '4955553535',\n// \t\t\t\tmobile: '9991234567',\n// \t\t\t\t...\n// \t\t\t},\n// \t\t\tformats:\n// \t\t\t[{\n// \t\t\t\tpattern: \"([3489]\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\n// \t\t\t\tleading_digits_patterns: [\"[3489]\"],\n// \t\t\t\tformat: \"$1 $2-$3-$4\"\n// \t\t\t},\n// \t\t\t...]\n// \t\t},\n// \t\t...\n// \t}\n// }\n//\n// `country_calling_codes` map is kinda redundant.\n// Not sure why did I choose to place country phone codes\n// into a separate structure inside metadata instead of generating it in runtime.\n// One extra feature it gives though is it tells what's the\n// \"default\" country for a given country phone code.\n// E.g. for country phone code `1` the \"default\" country is \"US\"\n// and therefore \"US\" is the first country code in the\n// `country_calling_codes[\"1\"]` list.\n// The \"default\" country is the one other countries\n// with the same country phone code inherit phone number formatting rules from.\n// For example, \"CA\" (Canada) inhertis phone number formatting rules from \"US\".\n//\n// `country_calling_codes` data takes about 3 KiloBytes\n// so it could kinda make sense to drop it from the metadata file\n// replacing it with a \"default\" country flag (something like `1` for \"yes\").\n// In that scenario `country_calling_codes` would be generated on startup.\n// It would have to also provide an exported `getCountryPhoneCodes()` function\n// which would take `metadata` and return `country_calling_codes` map\n// because some people use that `country_calling_codes` map in their projects.\n//\n// On the other hand, having `country_calling_codes`\n// prepopulated yields more elegance to the exports\n// because if `country_calling_codes` wasn't part of metadata\n// it would have to be computed somewhere in global scope\n// therefore the modules wouldn't be strictly \"pure\"\n// so maybe `country_calling_codes` stays as part of metadata.\n//\nexport default function(input, version, included_countries, extended, included_phone_number_types)\n{\n\t// Validate `included_phone_number_types`\n\tif (included_phone_number_types)\n\t{\n\t\tfor (const _type of included_phone_number_types)\n\t\t{\n\t\t\tif (phone_number_types.indexOf(_type) < 0)\n\t\t\t{\n\t\t\t\treturn Promise.reject(`Unknown phone number type: ${_type}`)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse the XML metadata\n\treturn parseStringPromisified(input).then((xml) =>\n\t{\n\t\t// https://github.com/googlei18n/libphonenumber/blob/master/resources/PhoneNumberMetadata.xml\n\t\t// https://github.com/googlei18n/libphonenumber/blob/master/resources/phonemetadata.proto\n\t\t// https://github.com/googlei18n/libphonenumber/blob/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\t\t// https://github.com/googlei18n/libphonenumber/blob/master/javascript/i18n/phonenumbers/asyoutypeformatter.js\n\n\t\tconst country_calling_code_to_countries = {}\n\t\tconst countries = {}\n\n\t\tfor (const territory of xml.phoneNumberMetadata.territories[0].territory)\n\t\t{\n\t\t\t// A two-letter country code\n\t\t\tconst country_code = territory.$.id\n\n\t\t\t// Skip this country if it has not been explicitly included\n\t\t\tif (included_countries && !included_countries.has(country_code))\n\t\t\t{\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Country metadata\n\t\t\tconst country =\n\t\t\t{\n\t\t\t\t// Phone code related fields:\n\n\t\t\t\t// Phone code for phone numbers in this country.\n\t\t\t\t//\n\t\t\t\t// E.g. `1` for both USA and Canada.\n\t\t\t\t//\n\t\t\t\tphone_code: territory.$.countryCode,\n\n\t\t\t\t// International Direct Dialing prefix.\n\t\t\t\tidd_prefix: territory.$.internationalPrefix,\n\t\t\t\tdefault_idd_prefix: territory.$.preferredInternationalPrefix,\n\n\t\t\t\t// Localized \" ext. \" prefix.\n\t\t\t\text: territory.$.preferredExtnPrefix,\n\n\t\t\t\t// In case of several countries\n\t\t\t\t// having the same country phone code,\n\t\t\t\t// these leading digits are the means\n\t\t\t\t// of classifying an international phone number\n\t\t\t\t// whether it belongs to a certain country.\n\t\t\t\t//\n\t\t\t\t// E.g. for Antigua and Barbuda\n\t\t\t\t// country phone code is `1` (same as USA)\n\t\t\t\t// and leading digits are `268`.\n\t\t\t\t//\n\t\t\t\tleading_digits: territory.$.leadingDigits,\n\n\t\t\t\t// The regular expression of all possible\n\t\t\t\t// national (significant) numbers for this country.\n\t\t\t\tnational_number_pattern: territory.generalDesc[0].nationalNumberPattern[0].replace(/\\s/g, ''),\n\n\t\t\t\t// National prefix related fields:\n\n\t\t\t\t// aka \"trunk code\".\n\t\t\t\t// This is the prefix prepended to a\n\t\t\t\t// national (significant) phone number\n\t\t\t\t// when dialed from within the country.\n\t\t\t\t// E.g. `0` for UK.\n\t\t\t\tnational_prefix: territory.$.nationalPrefix,\n\n\t\t\t\t// In some (many) countries the national prefix\n\t\t\t\t// is not just a constant digit (like `0` in UK)\n\t\t\t\t// but can be different depending on the phone number\n\t\t\t\t// (and can be also absent for some phone numbers).\n\t\t\t\t//\n\t\t\t\t// So `national_prefix_for_parsing` is used when parsing\n\t\t\t\t// a national-prefixed (local) phone number\n\t\t\t\t// into a national significant phone number\n\t\t\t\t// extracting that possible national prefix out of it.\n\t\t\t\t//\n\t\t\t\tnational_prefix_for_parsing : territory.$.nationalPrefixForParsing ? territory.$.nationalPrefixForParsing.replace(/\\s/g, '') : undefined,\n\n\t\t\t\t// If `national_prefix_for_parsing` regular expression\n\t\t\t\t// contains \"captured groups\", then `national_prefix_transform_rule`\n\t\t\t\t// defines how the national-prefixed (local) phone number is\n\t\t\t\t// parsed into a national significant phone number.\n\t\t\t\t//\n\t\t\t\t// Pseudocode:\n\t\t\t\t//\n\t\t\t\t// national_prefix_pattern = regular_expression('^(?:' + national_prefix_for_parsing + ')')\n\t\t\t\t// national_significant_number = all_digits.replace(national_prefix_pattern, national_prefix_transform_rule)\n\t\t\t\t//\n\t\t\t\t// E.g. if a country's national numbers are 6-digit\n\t\t\t\t// and national prefix is always `0`,\n\t\t\t\t// then `national_prefix_for_parsing` could be `0(\\d{6})`\n\t\t\t\t// and the corresponding `national_prefix_transform_rule` would be `$1`\n\t\t\t\t// (which is the default behaviour).\n\t\t\t\t//\n\t\t\t\t// Currently this feature is only used in\n\t\t\t\t// Argentina, Brazil, Mexico and San Marino\n\t\t\t\t// due to their messy telephone numbering plans.\n\t\t\t\t//\n\t\t\t\t// For example, mobile numbers in Argentina are written in two completely\n\t\t\t\t// different ways when dialed in-country and out-of-country\n\t\t\t\t// (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).\n\t\t\t\t// Therefore for Argentina `national_prefix_transform_rule` is `9$1`.\n\t\t\t\t//\n\t\t\t\tnational_prefix_transform_rule: territory.$.nationalPrefixTransformRule,\n\n\t\t\t\t// Controls how national prefix is written\n\t\t\t\t// in a formatted local phone number.\n\t\t\t\t//\n\t\t\t\t// E.g. in Armenia national prefix is `0`\n\t\t\t\t// and `national_prefix_formatting_rule` is `($NP$FG)`\n\t\t\t\t// which means that a national significant phone number `xxxxxxxx`\n\t\t\t\t// matching phone number pattern `(\\d{2})(\\d{6})` with format `$1 $2`\n\t\t\t\t// is written as a local phone number `(0xx) xxxxxx`.\n\t\t\t\t//\n\t\t\t\tnational_prefix_formatting_rule: national_prefix_formatting_rule(territory.$.nationalPrefixFormattingRule, territory.$.nationalPrefix),\n\n\t\t\t\t// Is it possible that a national (significant)\n\t\t\t\t// phone number has leading zeroes?\n\t\t\t\t//\n\t\t\t\t// E.g. in Gabon some numbers start with a `0`\n\t\t\t\t// while the national prefix is also `0`\n\t\t\t\t// which is optional for mobile numbers.\n\t\t\t\t//\n\t\t\t\tnational_prefix_is_optional_when_formatting: territory.$.nationalPrefixOptionalWhenFormatting ? Boolean(territory.$.nationalPrefixOptionalWhenFormatting) : undefined,\n\n\t\t\t\t// I suppose carrier codes can be omitted.\n\t\t\t\t// They are required only for Brazil and Columbia,\n\t\t\t\t// and only when calling to fixed line numbers\n\t\t\t\t// from mobile phones within those countries.\n\t\t\t\t// I guess people living in those countries\n\t\t\t\t// would know that they need to add carrier codes.\n\t\t\t\t// Other people don't need to know that.\n\t\t\t\t// Anyway, if someone sends a Pull Request\n\t\t\t\t// implementing carrier codes as Google's `libphonenumber` does\n\t\t\t\t// then such Pull Request will likely be merged.\n\t\t\t\t//\n\t\t\t\t// // In some countries carrier code is required\n\t\t\t\t// // to dial certain phone numbers.\n\t\t\t\t// //\n\t\t\t\t// // E.g. in Colombia calling to fixed line numbers\n\t\t\t\t// // from mobile phones requires a carrier code when called within Colombia.\n\t\t\t\t// // Or, for example, Brazilian fixed line and mobile numbers\n\t\t\t\t// // need to be dialed with a carrier code when called within Brazil.\n\t\t\t\t// // Without that, most of the carriers won't connect the call.\n\t\t\t\t// // These are the only two cases when \"carrier codes\" are required.\n\t\t\t\t// //\n\t\t\t\t// carrier_code_formatting_rule: territory.$.carrierCodeFormattingRule,\n\n\t\t\t\t// These `types` will be purged later,\n\t\t\t\t// if they're not needed (which is most likely).\n\t\t\t\t// See `country_calling_code_to_countries` ambiguity for more info.\n\t\t\t\t//\n\t\t\t\ttypes: get_phone_number_types(territory),\n\n\t\t\t\t// Will be filtered out during compression phase\n\t\t\t\texamples: get_phone_number_examples(territory)\n\t\t\t}\n\n\t\t\t// Check that national (significant) phone number pattern\n\t\t\t// is set for this country (no \"default\" value here)\n\t\t\tif (!country.national_number_pattern)\n\t\t\t{\n\t\t\t\tthrow new Error(`\"generalDesc.nationalNumberPattern\" is missing for country ${country_code} metadata`)\n\t\t\t}\n\n\t\t\t// Check that an IDD prefix is always defined.\n\t\t\tif (country_code !== '001' && !country.idd_prefix)\n\t\t\t{\n\t\t\t\tthrow new Error(`\"generalDesc.internationalPrefix\" is missing for country ${country_code} metadata`)\n\t\t\t}\n\n\t\t\t// // Check that a preferred IDD prefix is always defined if IDD prefix is a pattern.\n\t\t\t// if (country_code !== '001' && !isSingleIDDPrefix(country.idd_prefix) && !country.default_idd_prefix)\n\t\t\t// {\n\t\t\t// \tthrow new Error(`\"generalDesc.preferredInternationalPrefix\" is missing for country ${country_code} metadata`)\n\t\t\t// }\n\n\t\t\t// Some countries don't have `availableFormats` specified,\n\t\t\t// because those formats are inherited from the \"main country for region\".\n\t\t\tif (territory.availableFormats)\n\t\t\t{\n\t\t\t\tcountry.formats = territory.availableFormats[0].numberFormat.map((number_format) =>\n\t\t\t\t({\n\t\t\t\t\tpattern: number_format.$.pattern,\n\t\t\t\t\tleading_digits_patterns: number_format.leadingDigits ? number_format.leadingDigits.map(leading_digits => leading_digits.replace(/\\s/g, '')) : undefined,\n\t\t\t\t\tnational_prefix_formatting_rule: national_prefix_formatting_rule(number_format.$.nationalPrefixFormattingRule, territory.$.nationalPrefix),\n\t\t\t\t\tnational_prefix_is_optional_when_formatting: number_format.$.nationalPrefixOptionalWhenFormatting ? Boolean(number_format.$.nationalPrefixOptionalWhenFormatting) : undefined,\n\t\t\t\t\tformat: number_format.format[0],\n\t\t\t\t\tinternational_format: number_format.intlFormat ? number_format.intlFormat[0] : undefined\n\t\t\t\t}))\n\t\t\t\t// Screw local-only formats\n\t\t\t\t.filter(format => format.international_format !== 'NA')\n\n\t\t\t\t// Sanity check (using no \"default\" for this field)\n\t\t\t\tfor (const format of country.formats)\n\t\t\t\t{\n\t\t\t\t\t// Never happens\n\t\t\t\t\tif (!format.format)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Error(`No phone number format \"format\" supplied for pattern ${format.pattern} for ${country_code}`)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never happens\n\t\t\t\t\tif (format.format.indexOf(DIGIT_PLACEHOLDER) >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Error(`Phone number format \"${format.format}\" contains a reserved \"${DIGIT_PLACEHOLDER}\" symbol for pattern ${format.pattern} for ${country_code}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add this country's metadata\n\t\t\t// to the metadata map.\n\t\t\tcountries[country_code] = country\n\n\t\t\t// Register this country's \"country phone code\"\n\n\t\t\tif (!country_calling_code_to_countries[country.phone_code])\n\t\t\t{\n\t\t\t\tcountry_calling_code_to_countries[country.phone_code] = []\n\t\t\t}\n\n\t\t\t// In case of several countries\n\t\t\t// having the same country phone code.\n\t\t\t//\n\t\t\t// E.g. for USA and Canada, USA is the\n\t\t\t// \"main country for phone code 1\".\n\t\t\t//\n\t\t\t// (maybe this field is not used at all\n\t\t\t//  in which case this field is to be removed)\n\t\t\t//\n\t\t\tif (territory.$.mainCountryForCode === \"true\")\n\t\t\t{\n\t\t\t\tcountry_calling_code_to_countries[country.phone_code].unshift(country_code)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountry_calling_code_to_countries[country.phone_code].push(country_code)\n\t\t\t}\n\t\t}\n\n\t\t// Some countries don't have `availableFormats` specified,\n\t\t// because those formats are meant to be copied\n\t\t// from the \"main country for region\".\n\t\tfor (const country_code of Object.keys(countries))\n\t\t{\n\t\t\tconst country = countries[country_code]\n\n\t\t\tconst main_country_for_region_code = country_calling_code_to_countries[country.phone_code][0]\n\t\t\tconst main_country_for_region = countries[main_country_for_region_code]\n\t\t\tcountry.formats = main_country_for_region.formats\n\n\t\t\t// Some countries like Saint Helena and Falkland Islands\n\t\t\t// ('AC', 'FK', 'KI', 'NU', 'SH', 'TA', ...)\n\t\t\t// don't have any phone number formats\n\t\t\t// and phone numbers are formatted as a block in those countries.\n\t\t\tif (!country.formats)\n\t\t\t{\n\t\t\t\tcountry.formats = []\n\t\t\t}\n\t\t}\n\n\t\t// Turns out that `<generalDesc><nationalNumberPattern/></generalDesc>`\n\t\t// is not preemptive at all: it's too unspecific for the cases\n\t\t// when several countries correspond to the same country phone code\n\t\t// (e.g. NANPA: US, Canada, etc — all correspond to the same `1` country phone code).\n\t\t// For these cases all those bulky `<fixedLine/>`, `<mobile/>`, etc\n\t\t// patterns are required. Therefore retain them for these rare cases.\n\t\t//\n\t\t// This increases metadata size by 5 KiloBytes.\n\t\t//\n\t\tconst visited_countries = {}\n\t\tfor (const country_calling_code of Object.keys(country_calling_code_to_countries))\n\t\t{\n\t\t\tconst country_codes = country_calling_code_to_countries[country_calling_code]\n\n\t\t\tfor (const country_code of country_codes)\n\t\t\t{\n\t\t\t\tif (visited_countries[country_code])\n\t\t\t\t{\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvisited_countries[country_code] = true\n\n\t\t\t\t// Populate possible lengths\n\t\t\t\tpopulate_possible_lengths(countries[country_code])\n\t\t\t}\n\n\t\t\t// Purge `types` regular expressions (they are huge)\n\t\t\t// when they're not needed for resolving country phone code\n\t\t\t// to country phone number matching.\n\t\t\t// E.g. when there's a one-to-one correspondence\n\t\t\t// between a country phone code and a country code\n\t\t\tconst all_types_required = country_codes.length > 1\n\n\t\t\tif (!extended && !included_phone_number_types && !all_types_required)\n\t\t\t{\n\t\t\t\tdelete countries[country_codes[0]].types\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor (const country_code of country_codes)\n\t\t\t{\n\t\t\t\t// Leading digits for a country are sufficient\n\t\t\t\t// to resolve country phone code ambiguity.\n\t\t\t\t// So retaining all phone number type regular expressions\n\t\t\t\t// is not required in this case.\n\t\t\t\tif (!extended && !included_phone_number_types)\n\t\t\t\t{\n\t\t\t\t\tif (countries[country_code].leading_digits)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelete countries[country_code].types\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst types = countries[country_code].types\n\n\t\t\t\t// Find duplicate regular expressions for types\n\t\t\t\t// and just discard such duplicate types\n\t\t\t\t// to reduce metadata size (by 5 KiloBytes).\n\t\t\t\t// Or retain regular expressions just for the\n\t\t\t\t// specified phone number types (if configured).\n\t\t\t\tfor (const _type of phone_number_types)\n\t\t\t\t{\n\t\t\t\t\tif (!types[_type])\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retain regular expressions just for the\n\t\t\t\t\t// specified phone number types (if configured).\n\t\t\t\t\tif (included_phone_number_types)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!all_types_required && !included_phone_number_types.has(_type))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelete types[_type]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Remove redundant types\n\t\t\t\t\t// (other types having the same regular expressions as this one)\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Sometimes fixed line pattern is the same as for mobile.\n\t\t\t\t\t\tif (types.fixed_line && types.mobile &&\n\t\t\t\t\t\t\ttypes.fixed_line.pattern === types.mobile.pattern)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttypes.mobile.pattern = ''\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tversion,\n\t\t\tcountries,\n\t\t\tcountry_calling_codes: country_calling_code_to_countries\n\t\t}\n\t})\n}\n\n// Replaces $NP with national prefix and $FG with the first group ($1)\nfunction national_prefix_formatting_rule(rule, national_prefix)\n{\n\tif (!rule)\n\t{\n\t\treturn\n\t}\n\n\t// Replace $NP with national prefix and $FG with the first group ($1)\n\treturn rule\n\t\t.replace('$NP', national_prefix)\n\t\t.replace('$FG', '$1')\n}\n\n// Extracts various phone number type patterns from country XML metadata\nfunction get_phone_number_types(territory)\n{\n\treturn phone_number_types.reduce((output, type) =>\n\t{\n\t\tconst camel_cased_type = underscore_to_camel_case(type)\n\t\tconst pattern = territory[camel_cased_type] && territory[camel_cased_type][0].nationalNumberPattern[0].replace(/\\s/g, '')\n\t\tconst possible_lengths = territory[camel_cased_type] && territory[camel_cased_type][0].possibleLengths[0].$.national\n\t\tconst possible_lengths_local = territory[camel_cased_type] && territory[camel_cased_type][0].possibleLengths[0].$.localOnly\n\n\t\tif (pattern)\n\t\t{\n\t\t\toutput[type] =\n\t\t\t{\n\t\t\t\tpattern,\n\t\t\t\tpossible_lengths,\n\t\t\t\t// possible_lengths_local\n\t\t\t}\n\t\t}\n\n\t\treturn output\n\t},\n\t{})\n}\n\n// Extracts various phone number type examples from country XML metadata\nfunction get_phone_number_examples(territory)\n{\n\treturn phone_number_types.reduce((output, type) =>\n\t{\n\t\tconst camel_cased_type = underscore_to_camel_case(type)\n\t\tconst example = territory[camel_cased_type] && territory[camel_cased_type][0].exampleNumber[0]\n\n\t\tif (example)\n\t\t{\n\t\t\toutput[type] = example\n\t\t}\n\n\t\treturn output\n\t},\n\t{})\n}\n\nfunction underscore_to_camel_case(string)\n{\n\treturn string.replace(/(\\_\\w)/g, function(match)\n\t{\n\t\treturn match[1].toUpperCase()\n\t})\n}\n\n/**\n* Parses a possible length string into a set of the integers that are covered.\n*\n* @param {string} possible_length_string - A string specifying the possible lengths of phone numbers. Follows\n*     this syntax: ranges or elements are separated by commas, and ranges are specified in\n*     [min-max] notation, inclusive. For example, [3-5],7,9,[11-14] should be parsed to\n*     3,4,5,7,9,11,12,13,14.\n* @return {Set}\n*/\nfunction parse_possible_lengths(possible_length_string)\n{\n\tif (possible_length_string.length === 0)\n\t{\n\t\tthrow new TypeError('Empty possibleLength string found.')\n\t}\n\n\tconst lengths = new Set()\n\n\tfor (const length of possible_length_string.split(','))\n\t{\n\t\tif (length.length == 0)\n\t\t{\n\t\t\tthrow new TypeError(`Leading, trailing or adjacent commas in possible length string ${length}, these should only separate numbers or ranges.`)\n\t\t}\n\n\t\tif (length[0] === '[')\n\t\t{\n\t\t\tif (length[length.length - 1] !== ']')\n\t\t\t{\n\t\t\t\tthrow new TypeError(`Missing end of range character in possible length string ${length}.`)\n\t\t\t}\n\n\t\t\t// Strip the leading and trailing [], and split on the -.\n\t\t\tconst min_max = length.slice(1, length.length - 1).split('-').map(_ => parseInt(_))\n\n\t\t\tif (min_max.length !== 2)\n\t\t\t{\n\t\t\t\tthrow new TypeError(`Ranges must have exactly one - character: missing for ${length}.`)\n\t\t\t}\n\n\t\t\tconst [min, max] = min_max\n\n\t\t\t// We don't even accept [6-7] since we prefer the shorter 6,7 variant;\n\t\t\t// for a range to be in use the hyphen needs to replace at least one digit.\n\t\t\tif (max - min < 2)\n\t\t\t{\n\t\t\t\tthrow new TypeError(`The first number in a range should be two or more digits lower than the second. Culprit possibleLength string: ${length}`)\n\t\t\t}\n\n\t\t\tfor (let i = min; i <= max; i++)\n\t\t\t{\n\t\t\t\tif (lengths.has(i))\n\t\t\t\t{\n\t\t\t\t\tthrow new TypeError(`Duplicate length element found (${i}) in possibleLength string ${length}.`)\n\t\t\t\t}\n\n\t\t\t\tlengths.add(i)\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst i = parseInt(length)\n\n\t\t\tif (lengths.has(i))\n\t\t\t{\n\t\t\t\tthrow new TypeError(`Duplicate length element found (${i}) in possibleLength string ${length}.`)\n\t\t\t}\n\n\t\t\tlengths.add(i)\n\t\t}\n\t}\n\n\treturn lengths\n}\n\nconst arrays_are_equal = (a1, a2) => a1.length === a2.length && a1.every((_, i) => _ === a2[i])\n\nfunction populate_possible_lengths(metadata)\n{\n\tconst types = metadata.types\n\n\tconst possible_lengths = new Set()\n\tconst possible_lengths_local = new Set()\n\n\tfor (const _type of Object.keys(types))\n\t{\n\t\tconst type_possible_lengths = parse_possible_lengths(types[_type].possible_lengths)\n\n\t\tfor (const i of type_possible_lengths)\n\t\t{\n\t\t\tpossible_lengths.add(i)\n\t\t}\n\n\t\ttypes[_type].possible_lengths = Array.from(type_possible_lengths)\n\n\t\tif (types[_type].possible_lengths_local)\n\t\t{\n\t\t\tconst type_possible_lengths_local = parse_possible_lengths(types[_type].possible_lengths_local)\n\n\t\t\tfor (const i of type_possible_lengths_local)\n\t\t\t{\n\t\t\t\tpossible_lengths_local.add(i)\n\t\t\t}\n\n\t\t\ttypes[_type].possible_lengths_local = Array.from(type_possible_lengths_local)\n\t\t}\n\t}\n\n\tfor (const i of possible_lengths_local)\n\t{\n\t\tif (possible_lengths.has(i))\n\t\t{\n\t\t\tpossible_lengths_local.delete(i)\n\t\t}\n\t}\n\n\tmetadata.possible_lengths = Array.from(possible_lengths)\n\tmetadata.possible_lengths.sort((a, b) => a - b)\n\n\tif (possible_lengths_local.size > 0)\n\t{\n\t\tmetadata.possible_lengths_local = Array.from(possible_lengths_local)\n\t\tmetadata.possible_lengths_local.sort((a, b) => a - b)\n\t}\n\n\t// Remove duplicates.\n\tfor (const _type of Object.keys(types))\n\t{\n\t\tif (arrays_are_equal(types[_type].possible_lengths, metadata.possible_lengths))\n\t\t{\n\t\t\tdelete types[_type].possible_lengths\n\t\t}\n\n\t\tif (types[_type].possible_lengths_local && metadata.possible_lengths_local &&\n\t\t\tarrays_are_equal(types[_type].possible_lengths_local, metadata.possible_lengths_local))\n\t\t{\n\t\t\tdelete types[_type].possible_lengths_local\n\t\t}\n\t}\n}\n\nfunction parseStringPromisified(input)\n{\n\treturn new Promise((resolve, reject) =>\n\t{\n\t\tparseString(input, (error, result) =>\n\t\t{\n\t\t\tif (error)\n\t\t\t{\n\t\t\t\treturn reject(error)\n\t\t\t}\n\t\t\tresolve(result)\n\t\t})\n\t})\n}"]}