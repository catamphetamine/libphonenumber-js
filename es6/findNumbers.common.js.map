{"version":3,"sources":["../source/findNumbers.common.js"],"names":["PLUS_CHARS","isLatinLetter","isInvalidPunctuationSymbol","OPENING_PARENS","CLOSING_PARENS","LEAD_CLASS","LEAD_CLASS_LEADING","RegExp","MATCHING_BRACKETS_ENTIRE","openingParens","nonParens","closingParens","bracketPairLimit","PUB_PAGES","Leniency","POSSIBLE","number","candidate","metadata","parseNumber","extended","possible","VALID","isValidNumber","containsOnlyValidXChars","toString","isNationalPrefixPresentIfRequired","STRICT_GROUPING","candidateString","containsMoreThanOneSlashInNationalNumber","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","isValidCandidate","offset","text","leniency","test","previousChar","lastCharIndex","length","nextChar"],"mappings":"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","file":"findNumbers.common.js","sourcesContent":["// Copy-pasted from `PhoneNumberMatcher.js`.\n\nimport\n{\n\tPLUS_CHARS\n}\nfrom './common'\n\nimport\n{\n\tisLatinLetter,\n\tisInvalidPunctuationSymbol\n}\nfrom './utf-8.common'\n\nexport const OPENING_PARENS = '(\\\\[\\uFF08\\uFF3B'\nexport const CLOSING_PARENS = ')\\\\]\\uFF09\\uFF3D'\n\nexport const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`\n\n// Punctuation that may be at the start of a phone number - brackets and plus signs.\nconst LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)\n\n/**\n * Pattern to check that brackets match. Opening brackets should be closed within a phone number.\n * This also checks that there is something inside the brackets. Having no brackets at all is also\n * fine.\n *\n * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's\n * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a\n * closing bracket first. We limit the sets of brackets in a phone number to four.\n */\nconst MATCHING_BRACKETS_ENTIRE = new RegExp\n(\n\t'^'\n\n\t+ \"(?:[\" + openingParens + \"])?\" + \"(?:\" + nonParens + \"+\" + \"[\" + closingParens + \"])?\"\n\t+ nonParens + \"+\"\n\t+ \"(?:[\" + openingParens + \"]\" + nonParens + \"+[\" + closingParens + \"])\" + bracketPairLimit\n\t+ nonParens + \"*\"\n\n\t+ '$'\n)\n\n/**\n * Matches strings that look like publication pages. Example:\n * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.\n * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>\n *\n * The string \"211-227 (2003)\" is not a telephone number.\n */\nconst PUB_PAGES = /\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}/\n\n/**\n * Leniency when finding potential phone numbers in text segments\n * The levels here are ordered in increasing strictness.\n */\nexport const Leniency =\n{\n\t/**\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\n\t */\n\tPOSSIBLE(number, candidate, metadata)\n\t{\n\t\treturn parseNumber(number, { extended: true }, metadata).possible\n\t},\n\n\t/**\n\t * Phone numbers accepted are \"possible\" and \"valid\".\n\t * Numbers written in national format must have their national-prefix\n\t * present if it is usually written for a number of this type.\n\t */\n\tVALID(number, candidate, metadata)\n\t{\n\t\tif (!isValidNumber(number, metadata) ||\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn isNationalPrefixPresentIfRequired(number, metadata)\n  },\n\n\t/**\n\t * Phone numbers accepted are \"valid\" and\n\t * are grouped in a possible way for this locale. For example, a US number written as\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\n\t * Numbers with more than one '/' symbol in the national significant number\n\t * are also dropped at this level.\n\t *\n\t * Warning: This level might result in lower coverage especially for regions outside of\n\t * country code \"+1\". If you are not sure about which level to use,\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\n\t */\n\tSTRICT_GROUPING(number, candidate, metadata)\n\t{\n\t\tconst candidateString = candidate.toString()\n\n\t\tif (!isValidNumber(number, metadata)\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn checkNumberGroupingIsValid\n\t\t(\n\t\t\tnumber,\n\t\t\tcandidate,\n\t\t\tmetadata,\n\t\t\tallNumberGroupsRemainGrouped\n\t\t)\n  },\n\n\t/**\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\n\t * \"650 253 0000\" or \"6502530000\" are.\n\t * Numbers with more than one '/' symbol are also dropped at this level.\n\t * <p>\n\t * Warning: This level might result in lower coverage especially for regions outside of country\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\n\t * libphonenumber-discuss@googlegroups.com.\n\t */\n\tEXACT_GROUPING(number, candidate, metadata)\n\t{\n\t\tconst candidateString = candidate.toString()\n\n\t\tif (!isValidNumber(number, metadata)\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn checkNumberGroupingIsValid\n\t\t(\n\t\t\tnumber,\n\t\t\tcandidate,\n\t\t\tmetadata,\n   \t\tallNumberGroupsAreExactlyPresent\n\t\t)\n\t}\n}\n\nexport function isValidCandidate(candidate, offset, text, leniency)\n{\n\t// Check the candidate doesn't contain any formatting\n\t// which would indicate that it really isn't a phone number.\n\tif (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {\n\t\treturn\n\t}\n\n\t// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded\n\t// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.\n\tif (leniency !== Leniency.POSSIBLE)\n\t{\n\t\t// If the candidate is not at the start of the text,\n\t\t// and does not start with phone-number punctuation,\n\t\t// check the previous character.\n\t\tif (offset > 0 && !LEAD_CLASS_LEADING.test(candidate))\n\t\t{\n\t\t\tconst previousChar = text[offset - 1]\n\t\t\t// We return null if it is a latin letter or an invalid punctuation symbol.\n\t\t\tif (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tconst lastCharIndex = offset + candidate.length\n\t\tif (lastCharIndex < text.length)\n\t\t{\n\t\t\tconst nextChar = text[lastCharIndex]\n\t\t\tif (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}"]}