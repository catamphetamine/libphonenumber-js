{"version":3,"sources":["../source/format.js"],"names":["extractCountryCallingCode","VALID_PUNCTUATION","matches_entirely","getIDDPrefix","Metadata","formatRFC3966","defaultOptions","formatExtension","number","extension","metadata","ext","format","arg_1","arg_2","arg_3","arg_4","arg_5","sort_out_arguments","input","format_type","options","country","hasCountry","phone","countryCallingCode","selectedCountry","chooseCountryByCountryCallingCode","format_national_number","add_extension","fromCountry","IDDPrefix","humanReadable","formattedForSameCountryCallingCode","formatIDDSameCountryCallingCodeNumber","FIRST_GROUP_PATTERN","format_national_number_using_format","international","enforce_national_prefix","format_pattern_matcher","RegExp","pattern","national_prefix_may_be_omitted","nationalPrefixFormattingRule","nationalPrefixIsOptionalWhenFormatting","replace","formatted_number","internationalFormat","local_to_international_style","format_as","choose_format_for_number","formats","available_formats","national_number","leadingDigitsPatterns","length","last_leading_digits_pattern","search","local","trim","Error","is_object","TypeError","_","toCountryCallingCode","toCountryMetadata","fromCountryMetadata"],"mappings":"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","file":"format.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport\n{\n\textractCountryCallingCode,\n\tVALID_PUNCTUATION,\n\tmatches_entirely\n}\nfrom './common'\n\nimport { getIDDPrefix } from './IDD'\n\nimport Metadata from './metadata'\n\nimport { formatRFC3966 } from './RFC3966'\n\nconst defaultOptions =\n{\n\tformatExtension: (number, extension, metadata) => `${number}${metadata.ext()}${extension}`\n}\n\n// Formats a phone number\n//\n// Example use cases:\n//\n// ```js\n// format('8005553535', 'RU', 'International')\n// format('8005553535', 'RU', 'International', metadata)\n// format({ phone: '8005553535', country: 'RU' }, 'International')\n// format({ phone: '8005553535', country: 'RU' }, 'International', metadata)\n// format('+78005553535', 'National')\n// format('+78005553535', 'National', metadata)\n// ```\n//\nexport default function format(arg_1, arg_2, arg_3, arg_4, arg_5)\n{\n\tconst\n\t{\n\t\tinput,\n\t\tformat_type,\n\t\toptions,\n\t\tmetadata\n\t}\n\t= sort_out_arguments(arg_1, arg_2, arg_3, arg_4, arg_5)\n\n\tif (input.country && metadata.hasCountry(input.country))\n\t{\n\t\tmetadata.country(input.country)\n\t}\n\n\t// `number` is a national (significant) number in this case.\n\tlet { countryCallingCode, number } = extractCountryCallingCode(input.phone, null, metadata)\n\n\tcountryCallingCode = countryCallingCode || input.countryCallingCode\n\n\tif (countryCallingCode)\n\t{\n\t\t// Check country restriction\n\t\tif (input.country && metadata.selectedCountry() &&\n\t\t\tcountryCallingCode !== metadata.countryCallingCode())\n\t\t{\n\t\t\treturn input.phone\n\t\t}\n\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\n\t}\n\n\tif (!metadata.selectedCountry())\n\t{\n\t\treturn input.phone\n\t}\n\n\tswitch (format_type)\n\t{\n\t\tcase 'International':\n\t\t\tif (!number) {\n\t\t\t\treturn `+${metadata.countryCallingCode()}`\n\t\t\t}\n\t\t\tnumber = format_national_number(number, 'International', false, metadata)\n\t\t\tnumber = `+${metadata.countryCallingCode()} ${number}`\n\t\t\treturn add_extension(number, input.ext, metadata, options.formatExtension)\n\n\t\tcase 'E.164':\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\n\t\t\treturn `+${metadata.countryCallingCode()}${input.phone}`\n\n\t\tcase 'RFC3966':\n\t\t\treturn formatRFC3966\n\t\t\t({\n\t\t\t\tnumber : `+${metadata.countryCallingCode()}${input.phone}`,\n\t\t\t\text    : input.ext\n\t\t\t})\n\n\t\tcase 'IDD':\n\t\t\tif (!options.fromCountry) {\n\t\t\t\treturn\n\t\t\t\t// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\n\t\t\t}\n\t\t\tconst IDDPrefix = getIDDPrefix(options.fromCountry, metadata.metadata)\n\t\t\tif (!IDDPrefix) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (options.humanReadable)\n\t\t\t{\n\t\t\t\tconst formattedForSameCountryCallingCode = countryCallingCode && formatIDDSameCountryCallingCodeNumber(number, countryCallingCode, options.fromCountry, metadata)\n\t\t\t\tif (formattedForSameCountryCallingCode) {\n\t\t\t\t\tnumber = formattedForSameCountryCallingCode\n\t\t\t\t} else {\n\t\t\t\t\tnumber = `${IDDPrefix} ${metadata.countryCallingCode()} ${format_national_number(number, 'International', false, metadata)}`\n\t\t\t\t}\n\t\t\t\treturn add_extension(number, input.ext, metadata, options.formatExtension)\n\t\t\t}\n\t\t\treturn `${IDDPrefix}${metadata.countryCallingCode()}${number}`\n\n\t\tcase 'National':\n\t\t\tif (!number) {\n\t\t\t\treturn ''\n\t\t\t}\n\t\t\tnumber = format_national_number(number, 'National', false, metadata)\n\t\t\treturn add_extension(number, input.ext, metadata, options.formatExtension)\n\t}\n}\n\n// This was originally set to $1 but there are some countries for which the\n// first group is not used in the national pattern (e.g. Argentina) so the $1\n// group does not match correctly.  Therefore, we use \\d, so that the first\n// group actually used in the pattern will be matched.\nexport const FIRST_GROUP_PATTERN = /(\\$\\d)/\n\nexport function format_national_number_using_format(number, format, international, enforce_national_prefix, metadata)\n{\n\tconst format_pattern_matcher = new RegExp(format.pattern())\n\n\t// National prefix is omitted if there's no national prefix formatting rule\n\t// set for this country, or when this rule is set but\n\t// national prefix is optional for this phone number format\n\t// (and it is not enforced explicitly)\n\tconst national_prefix_may_be_omitted = !format.nationalPrefixFormattingRule() ||\n\t\t(format.nationalPrefixFormattingRule() && format.nationalPrefixIsOptionalWhenFormatting() && !enforce_national_prefix)\n\n\tif (!international && !national_prefix_may_be_omitted)\n\t{\n\t\treturn number.replace\n\t\t(\n\t\t\tformat_pattern_matcher,\n\t\t\tformat.format().replace\n\t\t\t(\n\t\t\t\tFIRST_GROUP_PATTERN,\n\t\t\t\tformat.nationalPrefixFormattingRule()\n\t\t\t)\n\t\t)\n\t}\n\n\tconst formatted_number = number.replace\n\t(\n\t\tformat_pattern_matcher,\n\t\tinternational ? format.internationalFormat() : format.format()\n\t)\n\n\tif (international)\n\t{\n\t\treturn local_to_international_style(formatted_number)\n\t}\n\n\treturn formatted_number\n}\n\nfunction format_national_number(number, format_as, enforce_national_prefix, metadata)\n{\n\tconst format = choose_format_for_number(metadata.formats(), number)\n\n\tif (!format)\n\t{\n\t\treturn number\n\t}\n\n\treturn format_national_number_using_format(number, format, format_as === 'International', enforce_national_prefix, metadata)\n}\n\nexport function choose_format_for_number(available_formats, national_number)\n{\n\tfor (const format of available_formats)\n\t{\n\t\t// Validate leading digits\n\t\tif (format.leadingDigitsPatterns().length > 0)\n\t\t{\n\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\n\t\t\tconst last_leading_digits_pattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]\n\n\t\t\t// If leading digits don't match then move on to the next phone number format\n\t\t\tif (national_number.search(last_leading_digits_pattern) !== 0)\n\t\t\t{\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Check that the national number matches the phone number format regular expression\n\t\tif (matches_entirely(national_number, format.pattern()))\n\t\t{\n\t\t\treturn format\n\t\t}\n\t}\n}\n\n// Removes brackets and replaces dashes with spaces.\n//\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\n//\nexport function local_to_international_style(local)\n{\n\treturn local.replace(new RegExp(`[${VALID_PUNCTUATION}]+`, 'g'), ' ').trim()\n}\n\n// Sort out arguments\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4, arg_5)\n{\n\tlet input\n\tlet format_type\n\tlet options\n\tlet metadata\n\n\t// Sort out arguments.\n\n\t// If the phone number is passed as a string.\n\t// `format('8005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\t// If country code is supplied.\n\t\t// `format('8005553535', 'RU', 'National', [options], metadata)`.\n\t\tif (typeof arg_3 === 'string')\n\t\t{\n\t\t\t// Will be `parse()`d later in code\n\t\t\tinput =\n\t\t\t{\n\t\t\t\tphone   : arg_1,\n\t\t\t\tcountry : arg_2\n\t\t\t}\n\n\t\t\tformat_type = arg_3\n\n\t\t\tif (arg_5)\n\t\t\t{\n\t\t\t\toptions  = arg_4\n\t\t\t\tmetadata = arg_5\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_4\n\t\t\t}\n\t\t}\n\t\t// Just an international phone number is supplied\n\t\t// `format('+78005553535', 'National', [options], metadata)`.\n\t\telse\n\t\t{\n\t\t\t// Will be `parse()`d later in code\n\t\t\tinput =\n\t\t\t{\n\t\t\t\tphone : arg_1\n\t\t\t}\n\n\t\t\tif (typeof arg_2 !== 'string')\n\t\t\t{\n\t\t\t\tthrow new Error('Format type argument not passed for `format()`')\n\t\t\t}\n\n\t\t\tformat_type = arg_2\n\n\t\t\tif (arg_4)\n\t\t\t{\n\t\t\t\toptions  = arg_3\n\t\t\t\tmetadata = arg_4\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_3\n\t\t\t}\n\t\t}\n\t}\n\t// If the phone number is passed as a parsed number object.\n\t// `format({ phone: '8005553535', country: 'RU' }, 'National', [options], metadata)`.\n\telse if (is_object(arg_1) && typeof arg_1.phone === 'string')\n\t{\n\t\tinput       = arg_1\n\t\tformat_type = arg_2\n\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions  = arg_3\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\n\n\t// Validate `format_type`.\n\tswitch (format_type)\n\t{\n\t\tcase 'International':\n\t\tcase 'E.164':\n\t\tcase 'National':\n\t\tcase 'RFC3966':\n\t\tcase 'IDD':\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown format type argument passed to \"format()\": \"${format_type}\"`)\n\t}\n\n\t// Apply default options.\n\tif (options) {\n\t\toptions = { ...defaultOptions, ...options }\n\t} else {\n\t\toptions = defaultOptions\n\t}\n\n\treturn { input, format_type, options, metadata: new Metadata(metadata) }\n}\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst is_object = _ => typeof _ === 'object'\n\nfunction add_extension(number, ext, metadata, formatExtension)\n{\n\treturn ext ? formatExtension(number, ext, metadata) : number\n}\n\nexport function formatIDDSameCountryCallingCodeNumber(number, toCountryCallingCode, fromCountry, toCountryMetadata)\n{\n\tconst fromCountryMetadata = new Metadata(toCountryMetadata.metadata)\n\tfromCountryMetadata.country(fromCountry)\n\n\t// If calling within the same country calling code.\n\tif (toCountryCallingCode === fromCountryMetadata.countryCallingCode())\n\t{\n\t\t// For NANPA regions, return the national format for these regions\n\t\t// but prefix it with the country calling code.\n\t\tif (toCountryCallingCode === '1')\n\t\t{\n\t\t\treturn toCountryCallingCode + ' ' + format_national_number(number, 'National', false, toCountryMetadata)\n\t\t}\n\n\t\t// If regions share a country calling code, the country calling code need\n\t\t// not be dialled. This also applies when dialling within a region, so this\n\t\t// if clause covers both these cases. Technically this is the case for\n\t\t// dialling from La Reunion to other overseas departments of France (French\n\t\t// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\n\t\t// this edge case for now and for those cases return the version including\n\t\t// country calling code. Details here:\n\t\t// http://www.petitfute.com/voyage/225-info-pratiques-reunion\n\t\treturn format_national_number(number, 'National', false, toCountryMetadata)\n\t}\n}"]}