{"version":3,"sources":["../source/parse.js"],"names":["extractCountryCallingCode","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","MAX_LENGTH_FOR_NSN","matches_entirely","create_extension_pattern","parseIncompletePhoneNumber","Metadata","getCountryCallingCode","get_number_type","check_number_length_for_type","parseRFC3966","MIN_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","default_options","country","parse","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","text","options","metadata","defaultCountry","hasCountry","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","national_number","countryCallingCode","carrierCode","selectedCountry","length","valid","nationalNumberPattern","extended","result","possible","possibleLengths","is_possible_number","undefined","phone","is_viable_phone_number","extract_formatted_phone_number","starts_at","search","slice","replace","strip_national_prefix_and_carrier_code","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","find_country_code","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","TypeError","strip_extension","start","number_without_extension","matches","match","i","is_international","indexOf","with_extension_stripped","default_country","chooseCountryByCountryCallingCode","parse_national_number","carrier_code","exactCountry","potential_national_number"],"mappings":"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","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport\n{\n\textractCountryCallingCode,\n\tVALID_DIGITS,\n\tVALID_PUNCTUATION,\n\tPLUS_CHARS,\n\tMAX_LENGTH_FOR_NSN,\n\tmatches_entirely,\n\tcreate_extension_pattern\n}\nfrom './common'\n\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\n\nimport Metadata from './metadata'\n\nimport getCountryCallingCode from './getCountryCallingCode'\n\nimport get_number_type, { check_number_length_for_type } from './getNumberType'\n\nimport { parseRFC3966 } from './RFC3966'\n\n// The minimum length of the national significant number.\nconst MIN_LENGTH_FOR_NSN = 2\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nconst MAX_INPUT_STRING_LENGTH = 250\n\n/**\n * Regexp of all possible ways to write extensions, for use when parsing. This\n * will be run as a case-insensitive regexp match. Wide character versions are\n * also provided after each ASCII version. There are three regular expressions\n * here. The first covers RFC 3966 format, where the extension is added using\n * ';ext='. The second more generic one starts with optional white space and\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\n * /commas and then the numbers themselves. The other one covers the special\n * case of American numbers where the extension is written with a hash at the\n * end, such as '- 503#'. Note that the only capturing groups should be around\n * the digits that you want to capture as part of the extension, or else parsing\n * will fail! We allow two options for representing the accented o - the\n * character itself, and one in the unicode decomposed form with the combining\n * acute accent.\n */\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\n\n// Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\n\n//  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  \"Note VALID_PUNCTUATION starts with a -,\n//   so must be the first in the range\" (c) Google devs.\n//  (wtf did they mean by saying that; probably nothing)\n//\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\n//\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\nconst VALID_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'(?:' +\n\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t'[' + VALID_DIGITS + ']' +\n\t'){3,}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\n// The combined regular expression for valid phone numbers:\n//\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\n(\n\t// Either a short two-digit-only phone number\n\t'^' +\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\n\t'$' +\n\t'|' +\n\t// Or a longer fully parsed phone number (min 3 characters)\n\t'^' +\n\t\tVALID_PHONE_NUMBER +\n\t\t// Phone number extensions\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\n\t'$'\n,\n'i')\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\n\n// Regular expression of trailing characters that we want to remove.\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\n\nconst default_options =\n{\n\tcountry: {}\n}\n\n// `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\nexport default function parse(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\t// Validate `defaultCountry`.\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\n\t{\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\n\t}\n\n\t// Parse the phone number.\n\tconst { number: formatted_phone_number, ext } = parse_input(text)\n\n\t// If the phone number is not viable then return nothing.\n\tif (!formatted_phone_number)\n\t{\n\t\treturn {}\n\t}\n\n\tconst\n\t{\n\t\tcountry,\n\t\tnational_number,\n\t\tcountryCallingCode,\n\t\tcarrierCode\n\t}\n\t= parse_phone_number\n\t(\n\t\tformatted_phone_number,\n\t\toptions.defaultCountry,\n\t\tmetadata\n\t)\n\n\tif (!metadata.selectedCountry())\n\t{\n\t\treturn {}\n\t}\n\n\t// Validate national (significant) number length.\n\t//\n\t// A sidenote:\n\t//\n\t// They say that sometimes national (significant) numbers\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n\t// Such numbers will just be discarded.\n\t//\n\tif (national_number.length < MIN_LENGTH_FOR_NSN ||\n\t\tnational_number.length > MAX_LENGTH_FOR_NSN)\n\t{\n\t\t// Google's demo just throws an error in this case.\n\t\treturn {}\n\t}\n\n\t// Check if national phone number pattern matches the number\n\t// National number pattern is different for each country,\n\t// even for those ones which are part of the \"NANPA\" group.\n\tconst valid = country && matches_entirely(national_number, metadata.nationalNumberPattern()) ? true : false\n\n\tif (!options.extended)\n\t{\n\t\treturn valid ? result(country, national_number, ext) : {}\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tcarrierCode,\n\t\tvalid,\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(national_number, countryCallingCode !== undefined, metadata),\n\t\tphone    : national_number,\n\t\text\n\t}\n}\n\n// Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\nexport function is_viable_phone_number(number)\n{\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\n\t\tmatches_entirely(number, VALID_PHONE_NUMBER_PATTERN)\n}\n\n/**\n * Extracts a parseable phone number.\n * @param  {string} text - Input.\n * @return {string}.\n */\nexport function extract_formatted_phone_number(text)\n{\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH)\n\t{\n\t\treturn\n\t}\n\n\t// Attempt to extract a possible number from the string passed in\n\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\n\n\tif (starts_at < 0)\n\t{\n\t\treturn\n\t}\n\n\treturn text\n\t\t// Trim everything to the left of the phone number\n\t\t.slice(starts_at)\n\t\t// Remove trailing non-numerical characters\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided.\n// \"Carrier codes\" are only used  in Colombia and Brazil,\n// and only when dialing within those countries from a mobile phone to a fixed line number.\nexport function strip_national_prefix_and_carrier_code(number, metadata)\n{\n\tif (!number || !metadata.nationalPrefixForParsing())\n\t{\n\t\treturn { number }\n\t}\n\n\t// Attempt to parse the first digits as a national prefix\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\n\n\t// If no national prefix is present in the phone number,\n\t// but the national prefix is optional for this country,\n\t// then consider this phone number valid.\n\t//\n\t// Google's reference `libphonenumber` implementation\n\t// wouldn't recognize such phone numbers as valid,\n\t// but I think it would perfectly make sense\n\t// to consider such phone numbers as valid\n\t// because if a national phone number was originally\n\t// formatted without the national prefix\n\t// then it must be parseable back into the original national number.\n\t// In other words, `parse(format(number))`\n\t// must always be equal to `number`.\n\t//\n\tif (!national_prefix_matcher)\n\t{\n\t\treturn { number }\n\t}\n\n\tlet national_significant_number\n\n\t// `national_prefix_for_parsing` capturing groups\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\tconst captured_groups_count = national_prefix_matcher.length - 1\n\n\t// If the national number tranformation is needed then do it.\n\t//\n\t// I don't know what did they mean by `&& national_prefix_matcher[captured_groups_count]`.\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/javascript/i18n/phonenumbers/phonenumberutil.js#L3885\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2906\n\t//\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\n\t{\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\n\t}\n\t// Else, no transformation is necessary,\n\t// and just strip the national prefix.\n\telse\n\t{\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\n\t}\n\n\tlet carrierCode\n\tif (captured_groups_count > 0)\n\t{\n\t\tcarrierCode = national_prefix_matcher[1]\n\t}\n\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\n\t//\n\t// // Verify the parsed national (significant) number for this country\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\n\t// //\n\t// // If the original number (before stripping national prefix) was viable,\n\t// // and the resultant number is not, then prefer the original phone number.\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\n\t// // a national prefix and a leading digit of a valid national phone number,\n\t// // like `8` is the national prefix for Russia and both\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t// if (matches_entirely(number, national_number_rule) &&\n\t// \t\t!matches_entirely(national_significant_number, national_number_rule))\n\t// {\n\t// \treturn number\n\t// }\n\n\t// Return the parsed national (significant) number\n   return {\n   \tnumber: national_significant_number,\n   \tcarrierCode\n   }\n}\n\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\n{\n\t// Is always non-empty, because `country_calling_code` is always valid\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\n\n\t// If there's just one country corresponding to the country code,\n\t// then just return it, without further phone number digits validation.\n\tif (possible_countries.length === 1)\n\t{\n\t\treturn possible_countries[0]\n\t}\n\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\n}\n\n// Changes `metadata` `country`.\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\n\tfor (const country of possible_countries)\n\t{\n\t\tmetadata.country(country)\n\n\t\t// Leading digits check would be the simplest one\n\t\tif (metadata.leadingDigits())\n\t\t{\n\t\t\tif (national_phone_number &&\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\n\t\t\t{\n\t\t\t\treturn country\n\t\t\t}\n\t\t}\n\t\t// Else perform full validation with all of those\n\t\t// fixed-line/mobile/etc regular expressions.\n\t\telse if (get_number_type({ phone: national_phone_number, country }, metadata.metadata))\n\t\t{\n\t\t\treturn country\n\t\t}\n\t}\n}\n\n// Sort out arguments\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n{\n\tlet text\n\tlet options\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `parse('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\ttext = arg_1\n\t}\n\telse throw new TypeError('A phone number for parsing must be a string.')\n\n\t// If \"default country\" argument is being passed\n\t// then move it to `options`.\n\t// `parse('88005553535', 'RU', [options], metadata)`.\n\tif (typeof arg_2 === 'string')\n\t{\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2 }\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\t// No \"default country\" argument is being passed.\n\t// International phone number is passed.\n\t// `parse('+78005553535', [options], metadata)`.\n\telse\n\t{\n\t\tif (arg_3)\n\t\t{\n\t\t\toptions  = arg_2\n\t\t\tmetadata = arg_3\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\t\t}\n\t}\n\n\t// Apply default options.\n\tif (options)\n\t{\n\t\toptions = { ...default_options, ...options }\n\t}\n\telse\n\t{\n\t\toptions = default_options\n\t}\n\n\treturn { text, options, metadata: new Metadata(metadata) }\n}\n\n// Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\nfunction strip_extension(number)\n{\n\tconst start = number.search(EXTN_PATTERN)\n\tif (start < 0)\n\t{\n\t\treturn {}\n\t}\n\n\t// If we find a potential extension, and the number preceding this is a viable\n\t// number, we assume it is an extension.\n\tconst number_without_extension = number.slice(0, start)\n\t/* istanbul ignore if - seems a bit of a redundant check */\n\tif (!is_viable_phone_number(number_without_extension))\n\t{\n\t\treturn {}\n\t}\n\n\tconst matches = number.match(EXTN_PATTERN)\n\tlet i = 1\n\twhile (i < matches.length)\n\t{\n\t\tif (matches[i] != null && matches[i].length > 0)\n\t\t{\n\t\t\treturn {\n\t\t\t\tnumber : number_without_extension,\n\t\t\t\text    : matches[i]\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n}\n\nfunction is_possible_number(national_number, is_international, metadata)\n{\n\tswitch (check_number_length_for_type(national_number, undefined, metadata))\n\t{\n\t\tcase 'IS_POSSIBLE':\n\t\t\treturn true\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\n\t\t// \treturn !is_international\n\t\tdefault:\n\t\t\treturn false\n\t}\n}\n\n/**\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?ext }`.\n */\nfunction parse_input(text)\n{\n\t// Parse RFC 3966 phone number URI.\n\tif (text && text.indexOf('tel:') === 0)\n\t{\n\t\treturn parseRFC3966(text)\n\t}\n\n\tlet number = extract_formatted_phone_number(text)\n\n\t// If the phone number is not viable, then abort.\n\tif (!number || !is_viable_phone_number(number))\n\t{\n\t\treturn {}\n\t}\n\n\t// Attempt to parse extension first, since it doesn't require region-specific\n\t// data and we want to have the non-normalised number here.\n\tconst with_extension_stripped = strip_extension(number)\n\tif (with_extension_stripped.ext)\n\t{\n\t\treturn with_extension_stripped\n\t}\n\n\treturn { number }\n}\n\n/**\n * Creates `parse()` result object.\n */\nfunction result(country, national_number, ext)\n{\n\tconst result =\n\t{\n\t\tcountry,\n\t\tphone : national_number\n\t}\n\n\tif (ext)\n\t{\n\t\tresult.ext = ext\n\t}\n\n\treturn result\n}\n\n/**\n * Parses a viable phone number.\n * Returns `{ country, countryCallingCode, national_number }`.\n */\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\n{\n\tlet { countryCallingCode, number } = extractCountryCallingCode(formatted_phone_number, default_country, metadata)\n\n\tif (!number) {\n\t\treturn { countryCallingCode }\n\t}\n\n\tlet country\n\n\tif (countryCallingCode)\n\t{\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\n\t}\n\telse if (default_country)\n\t{\n\t\tmetadata.country(default_country)\n\t\tcountry = default_country\n\t\tcountryCallingCode = getCountryCallingCode(default_country, metadata.metadata)\n\t}\n\telse return {}\n\n\tconst { national_number, carrier_code } = parse_national_number(number, metadata)\n\n\t// Sometimes there are several countries\n\t// corresponding to the same country phone code\n\t// (e.g. NANPA countries all having `1` country phone code).\n\t// Therefore, to reliably determine the exact country,\n\t// national (significant) number should have been parsed first.\n\t//\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\n\t// get their countries populated with the full set of\n\t// \"phone number type\" regular expressions.\n\t//\n\tconst exactCountry = find_country_code(countryCallingCode, national_number, metadata)\n\tif (exactCountry)\n\t{\n\t\tcountry = exactCountry\n\t\tmetadata.country(country)\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tnational_number,\n\t\tcarrierCode: carrier_code\n\t}\n}\n\nfunction parse_national_number(number, metadata)\n{\n\tlet national_number = parseIncompletePhoneNumber(number)\n\tlet carrier_code\n\n\t// Only strip national prefixes for non-international phone numbers\n\t// because national prefixes can't be present in international phone numbers.\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\n\t// and then it would assume that's a valid number which it isn't.\n\t// So no forgiveness for grandmas here.\n\t// The issue asking for this fix:\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\n\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(national_number, metadata)\n\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\n\tif (metadata.possibleLengths())\n\t{\n\t\t// We require that the NSN remaining after stripping the national prefix and\n\t\t// carrier code be long enough to be a possible length for the region.\n\t\t// Otherwise, we don't do the stripping, since the original number could be\n\t\t// a valid short number.\n\t\tswitch (check_number_length_for_type(potential_national_number, undefined, metadata))\n\t\t{\n\t\t\tcase 'TOO_SHORT':\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\n\t\t\tcase 'INVALID_LENGTH':\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tnational_number = potential_national_number\n\t\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\telse\n\t{\n\t\t// If the original number (before stripping national prefix) was viable,\n\t\t// and the resultant number is not, then prefer the original phone number.\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\n\t\t// a national prefix and a leading digit of a valid national phone number,\n\t\t// like `8` is the national prefix for Russia and both\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t\tif (matches_entirely(national_number, metadata.nationalNumberPattern()) &&\n\t\t\t\t!matches_entirely(potential_national_number, metadata.nationalNumberPattern()))\n\t\t{\n\t\t\t// Keep the number without stripping national prefix.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnational_number = potential_national_number\n\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\n\treturn {\n\t\tnational_number,\n\t\tcarrier_code\n\t}\n}\n\n// Determines the country for a given (possibly incomplete) phone number.\n// export function get_country_from_phone_number(number, metadata)\n// {\n// \treturn parse_phone_number(number, null, metadata).country\n// }"]}