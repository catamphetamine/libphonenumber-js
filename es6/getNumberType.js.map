{"version":3,"sources":["../source/getNumberType.js"],"names":["parse","is_viable_phone_number","matches_entirely","Metadata","non_fixed_line_types","get_number_type","arg_1","arg_2","arg_3","sort_out_arguments","input","metadata","country","hasCountry","Error","national_number","phone","nationalNumberPattern","is_of_type","type","pattern","_type","possibleLengths","indexOf","length","undefined","is_object","TypeError","check_number_length_for_type","type_info","possible_lengths","test_number_length_for_type","mobile_type","merge_arrays","actual_length","minimum_length","_","a","b","merged","slice","element","push","sort"],"mappings":"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","file":"getNumberType.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\n\nimport { matches_entirely } from './common'\n\nimport Metadata from './metadata'\n\nconst non_fixed_line_types =\n[\n\t'MOBILE',\n\t'PREMIUM_RATE',\n\t'TOLL_FREE',\n\t'SHARED_COST',\n\t'VOIP',\n\t'PERSONAL_NUMBER',\n\t'PAGER',\n\t'UAN',\n\t'VOICEMAIL'\n]\n\n// Finds out national phone number type (fixed line, mobile, etc)\nexport default function get_number_type(arg_1, arg_2, arg_3)\n{\n\tconst { input, metadata } = sort_out_arguments(arg_1, arg_2, arg_3)\n\n\t// When no input was passed\n\tif (!input)\n\t{\n\t\treturn\n\t}\n\n\t// When `parse()` returned `{}`\n\t// meaning that the phone number is not a valid one.\n\tif (!input.country)\n\t{\n\t\treturn\n\t}\n\n\tif (!metadata.hasCountry(input.country))\n\t{\n\t\tthrow new Error(`Unknown country: ${input.country}`)\n\t}\n\n\tconst national_number = input.phone\n\tmetadata.country(input.country)\n\n\t// The following is copy-pasted from the original function:\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n\t// Is this national number even valid for this country\n\tif (!matches_entirely(national_number, metadata.nationalNumberPattern()))\n\t{\n\t\treturn\n\t}\n\n\t// Is it fixed line number\n\tif (is_of_type(national_number, 'FIXED_LINE', metadata))\n\t{\n\t\t// Because duplicate regular expressions are removed\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\n\t\t//\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// v1 metadata.\n\t\t// Legacy.\n\t\t// Deprecated.\n\t\tif (!metadata.type('MOBILE'))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\n\t\t// (no such country in the minimal metadata set)\n\t\t/* istanbul ignore if */\n\t\tif (is_of_type(national_number, 'MOBILE', metadata))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\treturn 'FIXED_LINE'\n\t}\n\n\tfor (const _type of non_fixed_line_types)\n\t{\n\t\tif (is_of_type(national_number, _type, metadata))\n\t\t{\n\t\t\treturn _type\n\t\t}\n\t}\n}\n\nexport function is_of_type(national_number, type, metadata)\n{\n\ttype = metadata.type(type)\n\n\tif (!type || !type.pattern())\n\t{\n\t\treturn false\n\t}\n\n\t// Check if any possible number lengths are present;\n\t// if so, we use them to avoid checking\n\t// the validation pattern if they don't match.\n\t// If they are absent, this means they match\n\t// the general description, which we have\n\t// already checked before a specific number type.\n\tif (type.possibleLengths() &&\n\t\ttype.possibleLengths().indexOf(national_number.length) < 0)\n\t{\n\t\treturn false\n\t}\n\n\treturn matches_entirely(national_number, type.pattern())\n}\n\n// Sort out arguments\nexport function sort_out_arguments(arg_1, arg_2, arg_3)\n{\n\tlet input\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `getNumberType('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\t// If \"resrict country\" argument is being passed\n\t\t// then convert it to an `options` object.\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\n\t\tif (typeof arg_2 === 'string' || arg_2 === undefined)\n\t\t{\n\t\t\tmetadata = arg_3\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(arg_1))\n\t\t\t{\n\t\t\t\tinput = parse(arg_1, arg_2, metadata)\n\t\t\t}\n\t\t}\n\t\t// No \"resrict country\" argument is being passed.\n\t\t// International phone number is passed.\n\t\t// `getNumberType('+78005553535', metadata)`.\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(arg_1))\n\t\t\t{\n\t\t\t\tinput = parse(arg_1, metadata)\n\t\t\t}\n\t\t}\n\t}\n\t// If the phone number is passed as a parsed phone number.\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\n\telse if (is_object(arg_1) && typeof arg_1.phone === 'string')\n\t{\n\t\t// The `arg_1` must be a valid phone number\n\t\t// as a whole, not just a part of it which gets parsed here.\n\t\tif (is_viable_phone_number(arg_1.phone))\n\t\t{\n\t\t\tinput = arg_1\n\t\t}\n\n\t\tmetadata = arg_2\n\t}\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\n\n\treturn { input, metadata: new Metadata(metadata) }\n}\n\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\nexport function check_number_length_for_type(national_number, type, metadata)\n{\n\tconst type_info = metadata.type(type)\n\n\t// There should always be \"<possiblePengths/>\" set for every type element.\n\t// This is declared in the XML schema.\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n\t// so we fall back to the \"general description\". Where no numbers of the type\n\t// exist at all, there is one possible length (-1) which is guaranteed\n\t// not to match the length of any real phone number.\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n\n\tif (type === 'FIXED_LINE_OR_MOBILE')\n\t{\n\t\t// No such country in metadata.\n\t\t/* istanbul ignore next */\n\t\tif (!metadata.type('FIXED_LINE'))\n\t\t{\n\t\t\t// The rare case has been encountered where no fixedLine data is available\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\n\t\t\treturn test_number_length_for_type(national_number, 'MOBILE', metadata)\n\t\t}\n\n\t\tconst mobile_type = metadata.type('MOBILE')\n\n\t\tif (mobile_type)\n\t\t{\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\n\t\t\t// Note that when adding the possible lengths from mobile, we have\n\t\t\t// to again check they aren't empty since if they are this indicates\n\t\t\t// they are the same as the general desc and should be obtained from there.\n\t\t\tpossible_lengths = merge_arrays(possible_lengths, mobile_type.possibleLengths())\n\t\t\t// The current list is sorted; we need to merge in the new list and\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\n\t\t\t// the lists are very small.\n\n\t\t\t// if (local_lengths)\n\t\t\t// {\n\t\t\t// \tlocal_lengths = merge_arrays(local_lengths, mobile_type.possibleLengthsLocal())\n\t\t\t// }\n\t\t\t// else\n\t\t\t// {\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\n\t\t\t// }\n\t\t}\n\t}\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\n\telse if (type && !type_info)\n\t{\n\t\treturn 'INVALID_LENGTH'\n\t}\n\n\tconst actual_length = national_number.length\n\n\t// // This is safe because there is never an overlap beween the possible lengths\n\t// // and the local-only lengths; this is checked at build time.\n\t// if (local_lengths && local_lengths.indexOf(national_number.length) >= 0)\n\t// {\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n\t// }\n\n\tconst minimum_length = possible_lengths[0]\n\n\tif (minimum_length === actual_length)\n\t{\n\t\treturn 'IS_POSSIBLE'\n\t}\n\n\tif (minimum_length > actual_length)\n\t{\n\t\treturn 'TOO_SHORT'\n\t}\n\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\n\t{\n\t\treturn 'TOO_LONG'\n\t}\n\n\t// We skip the first element since we've already checked it.\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\n}\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst is_object = _ => typeof _ === 'object'\n\nexport function merge_arrays(a, b)\n{\n\tconst merged = a.slice()\n\n\tfor (const element of b)\n\t{\n\t\tif (a.indexOf(element) < 0)\n\t\t{\n\t\t\tmerged.push(element)\n\t\t}\n\t}\n\n\treturn merged.sort((a, b) => a - b)\n\n\t// ES6 version, requires Set polyfill.\n\t// let merged = new Set(a)\n\t// for (const element of b)\n\t// {\n\t// \tmerged.add(i)\n\t// }\n\t// return Array.from(merged).sort((a, b) => a - b)\n}"]}