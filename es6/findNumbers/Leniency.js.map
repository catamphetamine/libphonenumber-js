{"version":3,"sources":["../../source/findNumbers/Leniency.js"],"names":["parseNumber","isValidNumber","startsWith","endsWith","POSSIBLE","number","candidate","metadata","extended","possible","VALID","containsOnlyValidXChars","toString","isNationalPrefixPresentIfRequired","STRICT_GROUPING","candidateString","containsMoreThanOneSlashInNationalNumber","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","index","length","charAtIndex","charAt","charAtNextIndex","util","isNumberMatch","substring","MatchType","NSN_MATCH","PhoneNumberUtil","normalizeDigitsOnly","getExtension","_metadata","getCountryCodeSource","phoneNumberRegion","getRegionCodeForCountryCode","getCountryCode","getMetadataForRegion","nationalNumber","getNationalSignificantNumber","formatRule","chooseFormattingPatternForNumber","numberFormats","getNationalPrefixFormattingRule","getNationalPrefixOptionalWhenFormatting","formattingRuleHasFirstGroupOnly","rawInputCopy","getRawInput","maybeStripNationalPrefixAndCarrierCode","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","candidateHasCountryCode","CountryCodeSource","FROM_NUMBER_WITH_PLUS_SIGN","FROM_NUMBER_WITHOUT_PLUS_SIGN","String","slice","checkGroups","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","alternateFormats","MetadataManager","getAlternateFormatsForCountry","alternateFormat","formattingPattern","nationalSignificantNumber","formatNsnUsingPattern","split","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","NON_DIGITS_PATTERN","candidateNumberGroupIndex","hasExtension","contains","formattedNumberGroupIndex","fromIndex","FROM_DEFAULT_COUNTRY","countryCode","i","region","getNddPrefixForRegion","Character","isDigit"],"mappings":"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","file":"Leniency.js","sourcesContent":["import parseNumber from '../parse'\nimport isValidNumber from '../validate'\n\nimport\n{\n\tstartsWith,\n\tendsWith\n}\nfrom './util'\n\n/**\n * Leniency when finding potential phone numbers in text segments\n * The levels here are ordered in increasing strictness.\n */\nexport default\n{\n\t/**\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\n\t */\n\tPOSSIBLE(number, candidate, metadata)\n\t{\n\t\treturn parseNumber(number, { extended: true }, metadata).possible\n\t},\n\n\t/**\n\t * Phone numbers accepted are \"possible\" and \"valid\".\n\t * Numbers written in national format must have their national-prefix\n\t * present if it is usually written for a number of this type.\n\t */\n\tVALID(number, candidate, metadata)\n\t{\n\t\tif (!isValidNumber(number, metadata) ||\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn isNationalPrefixPresentIfRequired(number, metadata)\n  },\n\n\t/**\n\t * Phone numbers accepted are \"valid\" and\n\t * are grouped in a possible way for this locale. For example, a US number written as\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\n\t * Numbers with more than one '/' symbol in the national significant number\n\t * are also dropped at this level.\n\t *\n\t * Warning: This level might result in lower coverage especially for regions outside of\n\t * country code \"+1\". If you are not sure about which level to use,\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\n\t */\n\tSTRICT_GROUPING(number, candidate, metadata)\n\t{\n\t\tconst candidateString = candidate.toString()\n\n\t\tif (!isValidNumber(number, metadata)\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn checkNumberGroupingIsValid\n\t\t(\n\t\t\tnumber,\n\t\t\tcandidate,\n\t\t\tmetadata,\n\t\t\tallNumberGroupsRemainGrouped\n\t\t)\n  },\n\n\t/**\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\n\t * \"650 253 0000\" or \"6502530000\" are.\n\t * Numbers with more than one '/' symbol are also dropped at this level.\n\t * <p>\n\t * Warning: This level might result in lower coverage especially for regions outside of country\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\n\t * libphonenumber-discuss@googlegroups.com.\n\t */\n\tEXACT_GROUPING(number, candidate, metadata)\n\t{\n\t\tconst candidateString = candidate.toString()\n\n\t\tif (!isValidNumber(number, metadata)\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\n\t\t{\n\t\t\treturn false\n\t\t}\n\n\t\treturn checkNumberGroupingIsValid\n\t\t(\n\t\t\tnumber,\n\t\t\tcandidate,\n\t\t\tmetadata,\n   \t\tallNumberGroupsAreExactlyPresent\n\t\t)\n\t}\n}\n\nfunction containsOnlyValidXChars(number, candidate, metadata)\n{\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\n  // national significant number or (2) an extension sign, in which case they always precede the\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\n  // or 'X'. We ignore the character if it appears as the last character of the string.\n  for (let index = 0; index < candidate.length - 1; index++)\n  {\n    const charAtIndex = candidate.charAt(index)\n\n    if (charAtIndex === 'x' || charAtIndex === 'X')\n    {\n      const charAtNextIndex = candidate.charAt(index + 1)\n\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X')\n      {\n        // This is the carrier code case, in which the 'X's always precede the national\n        // significant number.\n        index++\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH)\n        {\n          return false\n        }\n\t      // This is the extension sign case, in which the 'x' or 'X' should always precede the\n\t      // extension number.\n      }\n      else if (!PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(index)) === number.getExtension())\n      {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\nfunction isNationalPrefixPresentIfRequired(number, _metadata)\n{\n  // First, check how we deduced the country code. If it was written in international format, then\n  // the national prefix is not required.\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY')\n  {\n    return true\n  }\n\n  const phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode())\n\n  const metadata = util.getMetadataForRegion(phoneNumberRegion)\n  if (metadata == null)\n  {\n    return true\n  }\n\n  // Check if a national prefix should be present when formatting this number.\n  const nationalNumber = util.getNationalSignificantNumber(number)\n  const formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber)\n\n  // To do this, we check that a national prefix formatting rule was present and that it wasn't\n  // just the first-group symbol ($1) with punctuation.\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0)\n  {\n    if (formatRule.getNationalPrefixOptionalWhenFormatting())\n    {\n      // The national-prefix is optional in these cases, so we don't need to check if it was\n      // present.\n      return true\n    }\n\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(\n        formatRule.getNationalPrefixFormattingRule()))\n    {\n      // National Prefix not needed for this number.\n      return true\n    }\n\n    // Normalize the remainder.\n    const rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput())\n\n    // Check if we found a national prefix and/or carrier code at the start of the raw input, and\n    // return the result.\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null)\n  }\n\n  return true\n}\n\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate)\n{\n  const firstSlashInBodyIndex = candidate.indexOf('/')\n  if (firstSlashInBodyIndex < 0)\n  {\n    // No slashes, this is okay.\n    return false\n  }\n\n  // Now look for a second one.\n  const secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\n  if (secondSlashInBodyIndex < 0)\n  {\n    // Only one slash, this is okay.\n    return false\n  }\n\n  // If the first slash is after the country calling code, this is permitted.\n  const candidateHasCountryCode =\n      (number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN\n       || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN)\n\n  if (candidateHasCountryCode\n      && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex))\n          === String(number.getCountryCode()))\n  {\n    // Any more slashes and this is illegal.\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\n  }\n\n  return true\n}\n\nfunction checkNumberGroupingIsValid\n(\n  number,\n  candidate,\n  metadata,\n  checkGroups\n)\n{\n  // TODO: Evaluate how this works for other locales (testing has been limited to NANPA regions)\n  // and optimise if necessary.\n  const normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\n  let formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups))\n  {\n    return true\n  }\n\n  // If this didn't pass, see if there are any alternate formats, and try them instead.\n  const alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\n\n  if (alternateFormats)\n  {\n    for (const alternateFormat of alternateFormats.numberFormats())\n    {\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\n\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\n/**\n * Helper method to get the national-number part of a number, formatted without any national\n * prefix, and return it as a set of digit blocks that would be formatted together.\n */\nfunction getNationalNumberGroups\n(\n\tmetadata,\n\tnumber,\n\tformattingPattern\n)\n{\n  if (formattingPattern)\n  {\n    // We format the NSN only, and split that according to the separator.\n    const nationalSignificantNumber = util.getNationalSignificantNumber(number)\n    return util.formatNsnUsingPattern(nationalSignificantNumber,\n                                      formattingPattern, 'RFC3966', metadata).split('-')\n\t}\n\n  // This will be in the format +CC-DG;ext=EXT where DG represents groups of digits.\n  const rfc3966Format = formatNumber(number, 'RFC3966', metadata)\n\n  // We remove the extension part from the formatted string before splitting it into different\n  // groups.\n  let endIndex = rfc3966Format.indexOf(';')\n  if (endIndex < 0) {\n    endIndex = rfc3966Format.length\n  }\n\n  // The country-code will have a '-' following it.\n  const startIndex = rfc3966Format.indexOf('-') + 1\n  return rfc3966Format.slice(startIndex, endIndex).split('-')\n}\n\nfunction allNumberGroupsAreExactlyPresent\n(\n\tmetadata,\n\tnumber,\n\tnormalizedCandidate,\n\tformattedNumberGroups\n)\n{\n  const candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\n\n  // Set this to the last group, skipping it if the number has an extension.\n  let candidateNumberGroupIndex =\n      number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\n\n  // First we check if the national significant number is formatted as a block.\n  // We use contains and not equals, since the national significant number may be present with\n  // a prefix such as a national number prefix, or the country code itself.\n  if (candidateGroups.length == 1\n      || candidateGroups[candidateNumberGroupIndex].contains(\n          util.getNationalSignificantNumber(number)))\n  {\n    return true\n  }\n\n  // Starting from the end, go through in reverse, excluding the first group, and check the\n  // candidate and number groups are the same.\n  let formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\n  {\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\n    {\n      return false\n    }\n    formattedNumberGroupIndex--\n    candidateNumberGroupIndex--\n  }\n\n  // Now check the first group. There may be a national prefix at the start, so we only check\n  // that the candidate group ends with the formatted number group.\n  return (candidateNumberGroupIndex >= 0\n      && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\n}\n\n\nfunction allNumberGroupsRemainGrouped\n(\n\tmetadata,\n\tnumber,\n\tnormalizedCandidate,\n\tformattedNumberGroups\n)\n{\n  let fromIndex = 0\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\n  {\n    // First skip the country code if the normalized candidate contained it.\n    const countryCode = String(number.getCountryCode())\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\n  }\n\n  // Check each group of consecutive digits are not broken into separate groupings in the\n  // {@code normalizedCandidate} string.\n  for (let i = 0; i < formattedNumberGroups.length; i++)\n  {\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\n    if (fromIndex < 0) {\n      return false\n    }\n    // Moves {@code fromIndex} forward.\n    fromIndex += formattedNumberGroups[i].length()\n    if (i == 0 && fromIndex < normalizedCandidate.length())\n    {\n      // We are at the position right after the NDC. We get the region used for formatting\n      // information based on the country code in the phone number, rather than the number itself,\n      // as we do not need to distinguish between different countries with the same country\n      // calling code and this is faster.\n      const region = util.getRegionCodeForCountryCode(number.getCountryCode())\n      if (util.getNddPrefixForRegion(region, true) != null\n          && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\n        // This means there is no formatting symbol after the NDC. In this case, we only\n        // accept the number if there is no formatting symbol at all in the number, except\n        // for extensions. This is only important for countries with national prefixes.\n        const nationalSignificantNumber = util.getNationalSignificantNumber(number)\n        return startsWith\n        (\n      \t  normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\n           nationalSignificantNumber\n        )\n      }\n    }\n  }\n\n  // The check here makes sure that we haven't mistakenly already used the extension to\n  // match the last group of the subscriber number. Note the extension cannot have\n  // formatting in-between digits.\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension())\n}"]}