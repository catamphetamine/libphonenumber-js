{"version":3,"sources":["../../source/findNumbers/isValidCandidate.js"],"names":["PLUS_CHARS","limit","isLatinLetter","isInvalidPunctuationSymbol","OPENING_PARENS","CLOSING_PARENS","NON_PARENS","LEAD_CLASS","LEAD_CLASS_LEADING","RegExp","BRACKET_PAIR_LIMIT","MATCHING_BRACKETS_ENTIRE","PUB_PAGES","isValidCandidate","candidate","offset","text","leniency","test","previousChar","lastCharIndex","length","nextChar"],"mappings":"AAAA;;AAEA,SAECA,UAFD,QAIK,WAJL;;AAMA,SAECC,KAFD,QAIK,QAJL;;AAMA,SAECC,aAFD,EAGCC,0BAHD,QAKK,SALL;;AAOA,IAAMC,iBAAiB,kBAAvB;AACA,IAAMC,iBAAiB,kBAAvB;AACA,IAAMC,oBAAkBF,cAAlB,GAAmCC,cAAnC,MAAN;;AAEA,OAAO,IAAME,mBAAiBH,cAAjB,GAAkCJ,UAAlC,MAAN;;AAEP;AACA,IAAMQ,qBAAqB,IAAIC,MAAJ,CAAW,MAAMF,UAAjB,CAA3B;;AAEA;AACA,IAAMG,qBAAqBT,MAAM,CAAN,EAAS,CAAT,CAA3B;;AAEA;;;;;;;;;AASA,IAAMU,2BAA2B,IAAIF,MAAJ,CAEhC,MACE,MADF,GACWL,cADX,GAC4B,KAD5B,GACoC,KADpC,GAC4CE,UAD5C,GACyD,GADzD,GAC+D,GAD/D,GACqED,cADrE,GACsF,KADtF,GAEEC,UAFF,GAEe,GAFf,GAGE,MAHF,GAGWF,cAHX,GAG4B,GAH5B,GAGkCE,UAHlC,GAG+C,IAH/C,GAGsDD,cAHtD,GAGuE,IAHvE,GAG8EK,kBAH9E,GAIEJ,UAJF,GAIe,GAJf,GAKE,GAP8B,CAAjC;;AAUA;;;;;;;AAOA,IAAMM,YAAY,kCAAlB;;AAEA,eAAe,SAASC,gBAAT,CAA0BC,SAA1B,EAAqCC,MAArC,EAA6CC,IAA7C,EAAmDC,QAAnD,EACf;AACC;AACA;AACA,KAAI,CAACN,yBAAyBO,IAAzB,CAA8BJ,SAA9B,CAAD,IAA6CF,UAAUM,IAAV,CAAeJ,SAAf,CAAjD,EAA4E;AAC3E;AACA;;AAED;AACA;AACA,KAAIG,aAAa,UAAjB,EACA;AACC;AACA;AACA;AACA,MAAIF,SAAS,CAAT,IAAc,CAACP,mBAAmBU,IAAnB,CAAwBJ,SAAxB,CAAnB,EACA;AACC,OAAMK,eAAeH,KAAKD,SAAS,CAAd,CAArB;AACA;AACA,OAAIZ,2BAA2BgB,YAA3B,KAA4CjB,cAAciB,YAAd,CAAhD,EAA6E;AAC5E,WAAO,KAAP;AACA;AACD;;AAED,MAAMC,gBAAgBL,SAASD,UAAUO,MAAzC;AACA,MAAID,gBAAgBJ,KAAKK,MAAzB,EACA;AACC,OAAMC,WAAWN,KAAKI,aAAL,CAAjB;AACA,OAAIjB,2BAA2BmB,QAA3B,KAAwCpB,cAAcoB,QAAd,CAA5C,EAAqE;AACpE,WAAO,KAAP;AACA;AACD;AACD;;AAED,QAAO,IAAP;AACA","file":"isValidCandidate.js","sourcesContent":["// Copy-pasted from `PhoneNumberMatcher.js`.\n\nimport\n{\n\tPLUS_CHARS\n}\nfrom '../common'\n\nimport\n{\n\tlimit\n}\nfrom './util'\n\nimport\n{\n\tisLatinLetter,\n\tisInvalidPunctuationSymbol\n}\nfrom './utf-8'\n\nconst OPENING_PARENS = '(\\\\[\\uFF08\\uFF3B'\nconst CLOSING_PARENS = ')\\\\]\\uFF09\\uFF3D'\nconst NON_PARENS = `[^${OPENING_PARENS}${CLOSING_PARENS}]`\n\nexport const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`\n\n// Punctuation that may be at the start of a phone number - brackets and plus signs.\nconst LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)\n\n// Limit on the number of pairs of brackets in a phone number.\nconst BRACKET_PAIR_LIMIT = limit(0, 3)\n\n/**\n * Pattern to check that brackets match. Opening brackets should be closed within a phone number.\n * This also checks that there is something inside the brackets. Having no brackets at all is also\n * fine.\n *\n * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's\n * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a\n * closing bracket first. We limit the sets of brackets in a phone number to four.\n */\nconst MATCHING_BRACKETS_ENTIRE = new RegExp\n(\n\t'^'\n\t+ \"(?:[\" + OPENING_PARENS + \"])?\" + \"(?:\" + NON_PARENS + \"+\" + \"[\" + CLOSING_PARENS + \"])?\"\n\t+ NON_PARENS + \"+\"\n\t+ \"(?:[\" + OPENING_PARENS + \"]\" + NON_PARENS + \"+[\" + CLOSING_PARENS + \"])\" + BRACKET_PAIR_LIMIT\n\t+ NON_PARENS + \"*\"\n\t+ '$'\n)\n\n/**\n * Matches strings that look like publication pages. Example:\n * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.\n * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>\n *\n * The string \"211-227 (2003)\" is not a telephone number.\n */\nconst PUB_PAGES = /\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}/\n\nexport default function isValidCandidate(candidate, offset, text, leniency)\n{\n\t// Check the candidate doesn't contain any formatting\n\t// which would indicate that it really isn't a phone number.\n\tif (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {\n\t\treturn\n\t}\n\n\t// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded\n\t// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.\n\tif (leniency !== 'POSSIBLE')\n\t{\n\t\t// If the candidate is not at the start of the text,\n\t\t// and does not start with phone-number punctuation,\n\t\t// check the previous character.\n\t\tif (offset > 0 && !LEAD_CLASS_LEADING.test(candidate))\n\t\t{\n\t\t\tconst previousChar = text[offset - 1]\n\t\t\t// We return null if it is a latin letter or an invalid punctuation symbol.\n\t\t\tif (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tconst lastCharIndex = offset + candidate.length\n\t\tif (lastCharIndex < text.length)\n\t\t{\n\t\t\tconst nextChar = text[lastCharIndex]\n\t\t\tif (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}"]}