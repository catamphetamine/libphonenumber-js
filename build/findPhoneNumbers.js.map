{"version":3,"sources":["../source/findPhoneNumbers.js"],"names":["findPhoneNumbers","searchPhoneNumbers","sort_out_arguments","VALID_PHONE_NUMBER","EXTN_PATTERNS_FOR_PARSING","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","WHITESPACE_IN_THE_END_PATTERN","arg_1","arg_2","arg_3","arg_4","text","options","metadata","search","PhoneNumberSearch","phones","hasNext","push","next","done","value","state","regexp","matches","exec","number","startsAt","index","replace","length","result","defaultCountry","phone","endsAt","find","last_match","Error","TypeError","countries"],"mappings":"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","file":"findPhoneNumbers.js","sourcesContent":["import parse from './parse'\nimport Metadata from './metadata'\n\nimport\n{\n\tPLUS_CHARS,\n\tVALID_PUNCTUATION,\n\tVALID_DIGITS,\n\t// OPENING_BRACKETS,\n\tWHITESPACE,\n\tcreate_extension_pattern\n}\nfrom './common'\n\n// Copy-pasted from `./parse.js`.\nconst VALID_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'(?:' +\n\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t'[' + VALID_DIGITS + ']' +\n\t'){3,}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\n\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\nconst WHITESPACE_IN_THE_END_PATTERN = new RegExp('[' + WHITESPACE + ']+$')\n\n// // Regular expression for getting opening brackets for a valid number\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\n\nexport default function findPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\n\n\tconst phones = []\n\n\twhile (search.hasNext())\n\t{\n\t\tphones.push(search.next())\n\t}\n\n\treturn phones\n}\n\n/**\n * @return ES6 `for ... of` iterator.\n */\nexport function searchPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\n\n\treturn  {\n\t\t[Symbol.iterator]() {\n\t\t\treturn {\n\t    \t\tnext: () => {\n\t    \t\t\tif (search.hasNext()) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\t\tvalue: search.next()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: true\n\t\t\t\t\t}\n\t    \t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts a parseable phone number including any opening brackets, etc.\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\n */\nexport class PhoneNumberSearch\n{\n\t// Iteration tristate.\n\tstate = 'NOT_READY'\n\n\tconstructor(text, options = {}, metadata)\n\t{\n\t\tthis.text = text\n\t\tthis.options = options\n\t\tthis.metadata = metadata\n\n\t\tthis.regexp = new RegExp\n\t\t(\n\t\t\tVALID_PHONE_NUMBER +\n\t\t\t// Phone number extensions\n\t\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?',\n\t\t\t'ig'\n\t\t)\n\n\t\t// this.searching_from = 0\n\t}\n\n\tfind()\n\t{\n\t\tconst matches = this.regexp.exec(this.text)\n\n\t\tif (!matches)\n\t\t{\n\t\t\treturn\n\t\t}\n\n\t\tlet number   = matches[0]\n\t\tlet startsAt = matches.index\n\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\n\t\tstartsAt += matches[0].length - number.length\n\t\tnumber = number.replace(WHITESPACE_IN_THE_END_PATTERN, '')\n\n\t\t// // Prepend any opening brackets left behind by the\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\n\t\t// if (full_number_starts_at >= 0)\n\t\t// {\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\n\t\t// \tstartsAt = full_number_starts_at\n\t\t// }\n\t\t//\n\t\t// this.searching_from = matches.lastIndex\n\n\t\tconst result = parse(number, { defaultCountry: this.options.defaultCountry }, this.metadata)\n\n\t\tif (result.phone)\n\t\t{\n\t\t\tresult.startsAt = startsAt\n\t\t\tresult.endsAt   = startsAt + number.length\n\n\t\t\treturn result\n\t\t}\n\n\t\t// Tail recursion.\n\t\t// Try the next one if this one is not a valid phone number.\n\t\treturn this.find()\n\t}\n\n\thasNext()\n\t{\n\t\tif (this.state === 'NOT_READY')\n\t\t{\n\t\t\tthis.last_match = this.find()\n\n\t\t\tif (this.last_match)\n\t\t\t{\n\t\t\t\tthis.state = 'READY'\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.state = 'DONE'\n\t\t\t}\n\t\t}\n\n\t\treturn this.state === 'READY'\n\t}\n\n\tnext()\n\t{\n\t\t// Check the state and find the next match as a side-effect if necessary.\n\t\tif (!this.hasNext())\n\t\t{\n\t\t\tthrow new Error('No next element')\n\t\t}\n\n\t\t// Don't retain that memory any longer than necessary.\n\t\tconst result = this.last_match\n\t\tthis.last_match = null\n\t\tthis.state = 'NOT_READY'\n\t\treturn result\n\t}\n}\n\nexport function sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n{\n\tlet text\n\tlet options\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `parse('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\ttext = arg_1\n\t}\n\telse throw new TypeError('A text for parsing must be a string.')\n\n\t// If \"default country\" argument is being passed\n\t// then move it to `options`.\n\t// `findNumbers('88005553535', 'RU', [options], metadata)`.\n\tif (typeof arg_2 === 'string')\n\t{\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2 }\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\t// No \"default country\" argument is being passed.\n\t// Only international phone numbers are passed.\n\t// `findNumbers('+78005553535', [options], metadata)`.\n\telse\n\t{\n\t\tif (arg_3)\n\t\t{\n\t\t\toptions  = arg_2\n\t\t\tmetadata = arg_3\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\t\t}\n\t}\n\n\t// Metadata is required.\n\tif (!metadata || !metadata.countries)\n\t{\n\t\tthrow new Error('Metadata is required')\n\t}\n\n\tif (!options)\n\t{\n\t\toptions = {}\n\t}\n\n\t// // Apply default options.\n\t// if (options)\n\t// {\n\t// \toptions = { ...default_options, ...options }\n\t// }\n\t// else\n\t// {\n\t// \toptions = default_options\n\t// }\n\n\treturn { text, options, metadata: new Metadata(metadata) }\n}"]}