{"version":3,"sources":["../source/common.js"],"names":["parse_phone_number_digits","parse_national_number_and_country_calling_code","matches_entirely","create_extension_pattern","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","LEADING_PLUS_CHARS_PATTERN","RegExp","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","DIGIT_MAPPINGS","number","test","drop_and_substitute_characters","metadata","i","length","countryCallingCode","slice","countryCallingCodes","text","regular_expression","matched_groups","match","replacements","replaced","character","replacement","toUpperCase","RFC3966_EXTN_PREFIX","CAPTURING_EXTN_DIGITS","purpose","single_extension_characters"],"mappings":"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","file":"common.js","sourcesContent":["// `DASHES` will be right after the opening square bracket of the \"character class\"\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\nconst SLASHES = '\\uFF0F/'\nconst DOTS = '\\uFF0E.'\nexport const WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\n// export const OPENING_BRACKETS = '(\\uFF08\\uFF3B\\\\\\['\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\n\n// Digits accepted in phone numbers\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\n\n// Regular expression of acceptable punctuation found in phone numbers. This\n// excludes punctuation found as a leading character only. This consists of dash\n// characters, white space characters, full stops, slashes, square brackets,\n// parentheses and tildes. Full-width variants are also present.\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\n\nexport const PLUS_CHARS = '+\\uFF0B'\nconst LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')\n\n// The ITU says the maximum length should be 15,\n// but one can find longer numbers in Germany.\nexport const MAX_LENGTH_FOR_NSN = 17\n\n// The maximum length of the country calling code.\nexport const MAX_LENGTH_COUNTRY_CODE = 3\n\n// These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport const DIGIT_MAPPINGS =\n{\n\t'0': '0',\n\t'1': '1',\n\t'2': '2',\n\t'3': '3',\n\t'4': '4',\n\t'5': '5',\n\t'6': '6',\n\t'7': '7',\n\t'8': '8',\n\t'9': '9',\n\t'\\uFF10': '0', // Fullwidth digit 0\n\t'\\uFF11': '1', // Fullwidth digit 1\n\t'\\uFF12': '2', // Fullwidth digit 2\n\t'\\uFF13': '3', // Fullwidth digit 3\n\t'\\uFF14': '4', // Fullwidth digit 4\n\t'\\uFF15': '5', // Fullwidth digit 5\n\t'\\uFF16': '6', // Fullwidth digit 6\n\t'\\uFF17': '7', // Fullwidth digit 7\n\t'\\uFF18': '8', // Fullwidth digit 8\n\t'\\uFF19': '9', // Fullwidth digit 9\n\t'\\u0660': '0', // Arabic-indic digit 0\n\t'\\u0661': '1', // Arabic-indic digit 1\n\t'\\u0662': '2', // Arabic-indic digit 2\n\t'\\u0663': '3', // Arabic-indic digit 3\n\t'\\u0664': '4', // Arabic-indic digit 4\n\t'\\u0665': '5', // Arabic-indic digit 5\n\t'\\u0666': '6', // Arabic-indic digit 6\n\t'\\u0667': '7', // Arabic-indic digit 7\n\t'\\u0668': '8', // Arabic-indic digit 8\n\t'\\u0669': '9', // Arabic-indic digit 9\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\n}\n\n/**\n * Drops all punctuation leaving only digits and the leading `+` sign (if any).\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\n *\n * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n *\n * @param  {string} number\n * @return {string}\n */\nexport function parse_phone_number_digits(number)\n{\n\treturn (LEADING_PLUS_CHARS_PATTERN.test(number) ? '+' : '') +\n\t\tdrop_and_substitute_characters(number, DIGIT_MAPPINGS)\n}\n\n// Parses a formatted phone number\n// and returns `{ country_calling_code, number }`\n// where `number` is the national (significant) phone number.\n//\n// (aka `maybeExtractCountryPhoneCode`)\n//\nexport function parse_national_number_and_country_calling_code(number, metadata)\n{\n\tnumber = parse_phone_number_digits(number)\n\n\tif (!number)\n\t{\n\t\treturn {}\n\t}\n\n\t// If this is not an international phone number,\n\t// then don't extract country phone code.\n\tif (number[0] !== '+')\n\t{\n\t\treturn { number }\n\t}\n\n\t// Fast abortion: country codes do not begin with a '0'\n\tif (number[1] === '0')\n\t{\n\t\treturn {}\n\t}\n\n\t// The thing with country phone codes\n\t// is that they are orthogonal to each other\n\t// i.e. there's no such country phone code A\n\t// for which country phone code B exists\n\t// where B starts with A.\n\t// Therefore, while scanning digits,\n\t// if a valid country code is found,\n\t// that means that it is the country code.\n\t//\n\tlet i = 2\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\n\t{\n\t\tconst countryCallingCode = number.slice(1, i)\n\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\n\t\t{\n\t\t\treturn {\n\t\t\t\tcountryCallingCode,\n\t\t\t\tnumber: number.slice(i)\n\t\t\t}\n\t\t}\n\n\t\ti++\n\t}\n\n\treturn {}\n}\n\n// Checks whether the entire input sequence can be matched\n// against the regular expression.\nexport function matches_entirely(text = '', regular_expression)\n{\n\tif (typeof regular_expression === 'string')\n\t{\n\t\tregular_expression = '^(?:' + regular_expression + ')$'\n\t}\n\n\tconst matched_groups = text.match(regular_expression)\n\treturn matched_groups !== null && matched_groups[0].length === text.length\n}\n\n// For any character not being part of `replacements`\n// it is removed from the phone number.\nfunction drop_and_substitute_characters(text, replacements)\n{\n\tlet replaced = ''\n\n\tfor (const character of text)\n\t{\n\t\tconst replacement = replacements[character.toUpperCase()]\n\n\t\tif (replacement)\n\t\t{\n\t\t\treplaced += replacement\n\t\t}\n\t}\n\n\treturn replaced\n}\n\n// The RFC 3966 format for extensions.\nconst RFC3966_EXTN_PREFIX = ';ext='\n\n// Pattern to capture digits used in an extension.\n// Places a maximum length of '7' for an extension.\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\n\n/**\n * Regexp of all possible ways to write extensions, for use when parsing. This\n * will be run as a case-insensitive regexp match. Wide character versions are\n * also provided after each ASCII version. There are three regular expressions\n * here. The first covers RFC 3966 format, where the extension is added using\n * ';ext='. The second more generic one starts with optional white space and\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\n * /commas and then the numbers themselves. The other one covers the special\n * case of American numbers where the extension is written with a hash at the\n * end, such as '- 503#'. Note that the only capturing groups should be around\n * the digits that you want to capture as part of the extension, or else parsing\n * will fail! We allow two options for representing the accented o - the\n * character itself, and one in the unicode decomposed form with the combining\n * acute accent.\n */\nexport function create_extension_pattern(purpose)\n{\n\t// One-character symbols that can be used to indicate an extension.\n\tlet single_extension_characters = 'x\\uFF58#\\uFF03~\\uFF5E'\n\n\tswitch (purpose)\n\t{\n\t\t// For parsing, we are slightly more lenient in our interpretation than for matching. Here we\n\t\t// allow \"comma\" and \"semicolon\" as possible extension indicators. When matching, these are\n\t\tcase 'parsing':\n\t\t\tsingle_extension_characters = ',;' + single_extension_characters\n\t}\n\n\treturn RFC3966_EXTN_PREFIX +\n\t\tCAPTURING_EXTN_DIGITS + '|' +\n\t\t'[ \\u00A0\\\\t,]*' +\n\t\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\n\t\t'[' + single_extension_characters + ']|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\n\t\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\n\t\tCAPTURING_EXTN_DIGITS + '#?|' +\n\t\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\n}"]}